#! C:/Program Files/Nuke16.0v3/nuke-16.0.3.dll -nx
version 16.0 v3
define_window_layout_xml {<?xml version="1.0" encoding="UTF-8"?>
<layout version="1.0">
    <window x="0" y="0" w="2559" h="1361" screen="0">
        <splitter orientation="1">
            <split size="40"/>
            <dock id="" hideTitles="1" activePageId="Toolbar.1">
                <page id="Toolbar.1"/>
            </dock>
            <split size="1896" stretch="1"/>
            <splitter orientation="2">
                <split size="773"/>
                <dock id="" activePageId="Viewer.1">
                    <page id="Viewer.1"/>
                </dock>
                <split size="543"/>
                <dock id="" activePageId="DAG.1" focus="true">
                    <page id="DAG.1"/>
                    <page id="Curve Editor.1"/>
                    <page id="DopeSheet.1"/>
                    <page id="DAG.2"/>
                </dock>
            </splitter>
            <split size="615"/>
            <dock id="" activePageId="Properties.1">
                <page id="Properties.1"/>
                <page id="uk.co.thefoundry.backgroundrenderview.1"/>
                <page id="Scenegraph.1"/>
            </dock>
        </splitter>
    </window>
</layout>
}
Root {
 inputs 0
 name projection_texture_bake_8_cams.nk
 proxy_type scale
 proxy_format "1024 778 0 0 1024 778 1 1K_Super_35(full-ap)"
 colorManagement Nuke
 workingSpaceLUT linear
 monitorLut sRGB
 monitorOutLUT rec709
 int8Lut sRGB
 int16Lut sRGB
 logLut Cineon
 floatLut linear
}
Group {
 inputs 0
 name Projection_Texture_Bake
 knobChanged "n=nuke.thisNode()\nk=nuke.thisKnob()\nif k.name() in ('asset_name', 'subname', 'showPanel'):\n import os, getpass\n p=os.environ.get('BUCK_PROJECT_PATH')\n u=getpass.getuser()\n a=n\['asset_name'].value()\n s=n\['subname'].value()\n if not p:\n  r=n.node('Read11')\n  if r:\n   f=r\['file'].value().replace('\\\\', '/')\n   if '/Production/' in f:\n    p=f.split('/Production/')\[0]\n msg = os.path.join(p, 'Production/MAYA/sourceimages/work.'+u+'/_CHARON', a, s).replace('\\\\', '/') if p else 'Path Not Found'\n n\['path_preview'].setValue(msg)\n"
 xpos 1192
 ypos 527
 addUserKnob {20 User}
 addUserKnob {30 uvsize l "UV size"}
 uvsize {8 1}
 addUserKnob {30 UVcoord l "UV coord"}
 addUserKnob {22 project_texture l "Project Texture" +STARTLINE T "n=nuke.thisNode()\n_DEBUG = False\n\ndef _debug(message):\n  if _DEBUG:\n    print('[TextureBake] ' + message)\n\ndef _resolve(node, max_hops=32):\n  cur=node\n  visited=set()\n  hops=0\n  while cur and hops<max_hops:\n    if cur in visited:\n      break\n    visited.add(cur)\n    try:\n      if cur.Class() not in ('Dot','NoOp'):\n        return cur\n    except Exception:\n      return cur\n    try:\n      cur=cur.input(0)\n    except Exception:\n      cur=None\n    hops+=1\n  return node\n\ndef _find_upstream(start_node, class_names, max_hops=32):\n  current=start_node\n  visited=set()\n  hops=0\n  while current and hops<max_hops:\n    if current in visited:\n      break\n    visited.add(current)\n    try:\n      if current.Class() in class_names:\n        return current\n    except Exception:\n      pass\n    try:\n      current=current.input(0)\n    except Exception:\n      current=None\n    hops+=1\n  return None\n\ndef _collect_rig_cam_count(rig):\n  if not rig or not hasattr(rig, 'begin'):\n    return 0\n  rig.begin()\n  try:\n    cams=[node for node in nuke.allNodes() if node.Class() in ('Camera3','Camera2','Camera') and node.name().startswith('Cam')]\n    return len(cams)\n  finally:\n    rig.end()\n\ndef _current_cam_count(group):\n  group.begin()\n  try:\n    cams=[node for node in nuke.allNodes() if node.Class() in ('Camera3','Camera2','Camera') and node.name().startswith('Cam')]\n    return len(cams)\n  finally:\n    group.end()\n\ndef _ensure_rig_count_knob(group):\n  knob=group.knob('charon_rig_cam_count')\n  if knob:\n    return knob\n  knob=nuke.Int_Knob('charon_rig_cam_count', 'Projection Cameras Found')\n  try:\n    knob.setEnabled(False)\n  except Exception:\n    knob.setFlag(nuke.DISABLED)\n  group.addKnob(knob)\n  return knob\n\ndef _update_rig_camera_count(group, rig):\n  count=_collect_rig_cam_count(rig)\n  knob=_ensure_rig_count_knob(group)\n  try:\n    knob.setValue(count)\n  except Exception:\n    try:\n      knob.setValue(int(count))\n    except Exception:\n      pass\n\ndef _read_group_block(template_path):
  try:
    with open(template_path, 'r') as handle:
      content=handle.read()
  except Exception as exc:
    _debug('failed to read template: \{0\}'.format(exc))
    return None

  lines=content.splitlines(True)
  start_line=None
  end_line=None
  depth=0
  for idx, line in enumerate(lines):
    stripped=line.lstrip()
    if stripped.startswith('Group \{'):
      if start_line is None:
        start_line=idx
      depth+=1
    elif stripped.startswith('end_group'):
      if depth > 0:
        depth-=1
        if depth == 0 and start_line is not None:
          end_line=idx
          break
  if start_line is None or end_line is None:
    _debug('template missing Group block')
    return None
  return ''.join(lines[start_line:end_line + 1]) + '\\n'

def _paste_group(script_content):\n  import tempfile\n  temp_path=''\n  try:\n    with tempfile.NamedTemporaryFile(mode='w', suffix='.nk', delete=False) as handle:\n      handle.write(script_content)\n      temp_path=handle.name\n    for node in nuke.allNodes():\n      node.setSelected(False)\n    nuke.nodePaste(temp_path)\n    for node in nuke.selectedNodes():\n      if node.Class()=='Group':\n        return node\n  except Exception as exc:\n    _debug('paste failed: \{0\}'.format(exc))\n  finally:\n    if temp_path and os.path.exists(temp_path):\n      try:\n        os.unlink(temp_path)\n      except Exception:\n        pass\n  return None\n\ndef _collect_dependents(node):\n  deps=[]\n  for other in nuke.allNodes(recurseGroups=False):\n    for i in range(other.inputs()):\n      try:\n        if other.input(i)==node:\n          deps.append((other,i))\n      except Exception:\n        pass\n  return deps\n\ndef _ensure_template_knob(group):\n  knob=group.knob('charon_template_dir')\n  if knob:\n    return knob\n  knob=nuke.String_Knob('charon_template_dir','Template Dir','')\n  knob.setFlag(nuke.NO_ANIMATION | nuke.INVISIBLE)\n  group.addKnob(knob)\n  return knob\n\ndef _copy_knob_values(src, dst, names):\n  for name in names:\n    try:\n      if src.knob(name) and dst.knob(name):\n        dst[name].setValue(src[name].value())\n    except Exception:\n      pass\n\n\ndef _unique_name(base):\n  try:\n    existing=set(n.name() for n in nuke.allNodes(recurseGroups=False))\n  except Exception:\n    existing=set()\n  if base not in existing:\n    return base\n  idx=1\n  while True:\n    candidate='\{0\}_\{1\}'.format(base, idx)\n    if candidate not in existing:\n      return candidate\n    idx+=1\n\ndef _rebuild_for_count(group, count):\n  try:\n    count=int(count)\n  except Exception:\n    return None\n  template_dir=''\n  try:\n    template_dir=group['charon_template_dir'].value()\n  except Exception:\n    template_dir=''\n  if not template_dir:\n    nuke.message('Template directory missing.')\n    return None\n  template_path=os.path.normpath(os.path.join(template_dir, 'projection_texture_bake_\{0\}_cams.nk'.format(count)))\n  if not os.path.exists(template_path):\n    nuke.message('Template not found for \{0\} cams.'.format(count))\n    return None\n  script_content=_read_group_block(template_path)\n  if not script_content:\n    return None\n\n  input_nodes=[group.input(i) for i in range(group.inputs())]\n  old_name=group.name()\n  old_pos=(group.xpos(), group.ypos())\n  downstream=_collect_dependents(group)\n  values=\{\}\n  for name in ['asset_name','subname','aces_mode','uvsize','bake_resolution']:\n    try:\n      if group.knob(name):\n        values[name]=group[name].value()\n    except Exception:\n      pass\n\n  root=nuke.root()\n  current_group=nuke.thisGroup()\n  root.begin()\n  new_group=_paste_group(script_content)\n  if not new_group:\n    nuke.message('Failed to rebuild bake group.')\n    return None\n\n  for idx, inp in enumerate(input_nodes):\n    try:\n      new_group.setInput(idx, inp)\n    except Exception:\n      pass\n  try:\n    new_group.setXYpos(old_pos[0], old_pos[1])\n  except Exception:\n    pass\n  _copy_knob_values(group, new_group, values.keys())\n\n  for dep, idx in downstream:\n    try:\n      dep.setInput(idx, new_group)\n    except Exception:\n      pass\n\n  temp_name=_unique_name('\{0\}_OLD'.format(old_name))\n  try:\n    group.setName(temp_name)\n  except Exception:\n    pass\n  try:\n    new_group.setName(old_name)\n  except Exception:\n    pass\n  try:\n    nuke.delete(group)\n  except Exception:\n    pass\n\n  _ensure_template_knob(new_group)\n  try:\n    new_group['charon_template_dir'].setValue(template_dir)\n  except Exception:\n    pass\n\n  if current_group and current_group is not root:\n    current_group.begin()\n  return new_group\n\ndef _update_geo(group, geo_node):\n  if not geo_node:\n    return False\n  _debug('update_geo input: \{0\} (\{1\})'.format(geo_node.name(), geo_node.Class()))\n  if geo_node.Class() not in ('ReadGeo2','ReadGeo'):\n    upstream=_find_upstream(geo_node, ('ReadGeo2','ReadGeo'))\n    if upstream:\n      _debug('resolved upstream geo: \{0\} (\{1\})'.format(upstream.name(), upstream.Class()))\n      geo_node=upstream\n    else:\n      nuke.message('Geo input must be a ReadGeo/ReadGeo2 node.')\n      return False\n\n  root=nuke.root()\n  current_group=nuke.thisGroup()\n  root.begin()\n  original_selection=list(nuke.selectedNodes())\n  for n in original_selection:\n    n.setSelected(False)\n  try:\n    geo_node.setSelected(True)\n    nuke.nodeCopy('%clipboard%')\n  finally:\n    geo_node.setSelected(False)\n    for n in original_selection:\n      try:\n        n.setSelected(True)\n      except Exception:\n        pass\n    if current_group and current_group is not root:\n      current_group.begin()\n\n  group.begin()\n  try:\n    before_nodes=set(nuke.allNodes())\n    for n in nuke.selectedNodes():\n      n.setSelected(False)\n    nuke.nodePaste('%clipboard%')\n    pasted_nodes=list(nuke.selectedNodes())\n    after_nodes=[node for node in nuke.allNodes() if node not in before_nodes]\n    if not after_nodes and not pasted_nodes:\n      nuke.message('Failed to paste geo node.')\n      return False\n\n    pasted=None\n    for node in pasted_nodes + after_nodes:\n      if node.Class() in ('ReadGeo2','ReadGeo'):\n        pasted=node\n        break\n    if pasted is None:\n      pasted=(pasted_nodes or after_nodes)[0]\n\n    existing_geos=[node for node in nuke.allNodes() if node.Class() in ('ReadGeo2','ReadGeo') and node is not pasted]\n\n    def _is_clone(node):\n      try:\n        return bool(node.isClone())\n      except Exception:\n        return False\n\n    def _collect_connections(nodes):\n      connections=\{node: [] for node in nodes\}\n      for node in nuke.allNodes():\n        for i in range(node.inputs()):\n          try:\n            inp=node.input(i)\n          except Exception:\n            continue\n          if inp in connections:\n            connections[inp].append((node,i))\n      return connections\n\n    def _create_clone(master):\n      for n in nuke.selectedNodes():\n        n.setSelected(False)\n      master.setSelected(True)\n      before=set(nuke.allNodes())\n      if hasattr(nuke, 'clone'):\n        try:\n          nuke.clone(master)\n        except TypeError:\n          nuke.clone()\n      else:\n        nuke.nodeCopy('%clipboard%')\n        nuke.nodePaste('%clipboard%')\n      created=[node for node in nuke.allNodes() if node not in before]\n      if created:\n        return created[0]\n      return None\n\n    if not existing_geos:\n      default_name='ReadGeo' if geo_node.Class()=='ReadGeo' else 'ReadGeo2'\n      try:\n        pasted.setName(default_name, unique=True)\n      except Exception:\n        pasted.setName(default_name)\n      return True\n\n    master_old=None\n    for node in existing_geos:\n      if node.name() in ('ReadGeo2','ReadGeo'):\n        master_old=node\n        break\n    if master_old is None:\n      for node in existing_geos:\n        if not _is_clone(node):\n          master_old=node\n          break\n    if master_old is None:\n      master_old=existing_geos[0]\n\n    geo_specs=[]\n    for node in existing_geos:\n      try:\n        input_nodes=[node.input(i) for i in range(node.inputs())]\n      except Exception:\n        input_nodes=[]\n      geo_specs.append(\{\n        'node': node,\n        'name': node.name(),\n        'pos': (node.xpos(), node.ypos()),\n        'is_master': node is master_old,\n        'inputs': input_nodes,\n      \})\n    connections=_collect_connections([spec['node'] for spec in geo_specs])\n\n    new_nodes=\{\}\n    for spec in geo_specs:\n      if spec['is_master']:\n        new_nodes[spec['node']]=pasted\n      else:\n        clone=_create_clone(pasted)\n        if clone:\n          new_nodes[spec['node']]=clone\n        else:\n          new_nodes[spec['node']]=pasted\n\n    for spec in geo_specs:\n      old_node=spec['node']\n      new_node=new_nodes.get(old_node)\n      if new_node is None:\n        continue\n      inputs=spec.get('inputs', [])\n      for idx, inp in enumerate(inputs):\n        if inp is None:\n          try:\n            new_node.setInput(idx, None)\n          except Exception:\n            pass\n          continue\n        replacement=new_nodes.get(inp, inp)\n        try:\n          new_node.setInput(idx, replacement)\n        except Exception:\n          pass\n\n    for old_node, new_node in new_nodes.items():\n      if old_node is new_node:\n        continue\n      for dep, idx in connections.get(old_node, []):\n        try:\n          dep.setInput(idx, new_node)\n        except Exception:\n          pass\n\n    for spec in geo_specs:\n      old_node=spec['node']\n      new_node=new_nodes.get(old_node)\n      if new_node is None:\n        continue\n      try:\n        new_node.setXYpos(spec['pos'][0], spec['pos'][1])\n      except Exception:\n        pass\n\n    for spec in geo_specs:\n      old_node=spec['node']\n      try:\n        nuke.delete(old_node)\n      except Exception:\n        pass\n\n    for spec in geo_specs:\n      new_node=new_nodes.get(spec['node'])\n      if new_node is None:\n        continue\n      try:\n        new_node.setName(spec['name'], unique=True)\n      except Exception:\n        try:\n          new_node.setName(spec['name'])\n        except Exception:\n          pass\n\n    return True\n  finally:\n    group.end()\n\ndef _update_uv_size(group, geo_node):
  if not geo_node:
    _debug('uv size: geo input missing')
    return
  _debug('uv size: geo input ' + geo_node.name() + ' (' + geo_node.Class() + ')')
  if geo_node.Class() not in ('ReadGeo2','ReadGeo'):
    upstream=_find_upstream(geo_node, ('ReadGeo2','ReadGeo'))
    if upstream:
      _debug('uv size: resolved geo ' + upstream.name() + ' (' + upstream.Class() + ')')
      geo_node=upstream
    else:
      _debug('uv size: uv source must be ReadGeo/ReadGeo2')
      return
  root=nuke.root()
  current_group=nuke.thisGroup()
  root.begin()
  try:
    def _get_geometry(node):
      if not hasattr(node, 'geometry'):
        _debug('uv size: geometry() not available on ' + node.Class())
        return None
      geo=None
      try:
        geo=node.geometry(nuke.frame())
        _debug('uv size: geometry(frame) ok')
      except Exception as exc:
        _debug('uv size: geometry(frame) failed: ' + str(exc))
      if not geo:
        try:
          geo=node.geometry()
          _debug('uv size: geometry() ok')
        except Exception as exc2:
          _debug('uv size: geometry() failed: ' + str(exc2))
      return geo

    def _collect_uvs_from_geo(geo):
      uvs=[]
      try:
        attr=None
        try:
          attr=geo.pointAttrib('uv')
        except Exception:
          attr=None
        if attr:
          _debug('uv size: using point attrib uv')
          for p in geo.points():
            try:
              uv=attr.value(p)
            except Exception:
              try:
                uv=p.attribValue(attr)
              except Exception:
                uv=None
            if uv:
              uvs.append(uv)
      except Exception as exc:
        _debug('uv size: point attrib read failed: ' + str(exc))
      if not uvs:
        try:
          for p in geo.points():
            uv=None
            try:
              attrs=p.attributes()
              if attrs:
                uv=attrs.get('uv')
            except Exception:
              uv=None
            if uv is None:
              try:
                uv=p.attribValue('uv')
              except Exception:
                uv=None
            if uv:
              uvs.append(uv)
        except Exception as exc:
          _debug('uv size: point attrib fallback failed: ' + str(exc))
      if not uvs:
        try:
          attr=None
          try:
            attr=geo.vertexAttrib('uv')
          except Exception:
            attr=None
          if attr:
            _debug('uv size: using vertex attrib uv')
            for vtx in geo.vertices():
              try:
                uv=attr.value(vtx)
              except Exception:
                try:
                  uv=vtx.attribValue(attr)
                except Exception:
                  uv=None
              if uv:
                uvs.append(uv)
        except Exception as exc:
          _debug('uv size: vertex attrib read failed: ' + str(exc))
      return uvs

    def _compute_range(uvs):
      import math
      min_idx=None
      max_idx=None
      for uv in uvs:
        try:
          u=float(uv[0])
          v=float(uv[1])
        except Exception:
          continue
        tile_u=int(math.floor(u))
        tile_v=int(math.floor(v))
        idx=tile_u + (tile_v * 10)
        if min_idx is None or idx < min_idx:
          min_idx=idx
        if max_idx is None or idx > max_idx:
          max_idx=idx
      return min_idx, max_idx

    def _apply_range(min_idx, max_idx):
      if min_idx is None or max_idx is None:
        _debug('uv size: compute failed')
        return False
      try:
        group['uvsize'].setValue([int(min_idx), int(max_idx)])
        _debug('uv size: set to ' + str(int(min_idx)) + '-' + str(int(max_idx)))
        return True
      except Exception as exc:
        _debug('uv size: set failed: ' + str(exc))
        return False

    geo=_get_geometry(geo_node)
    if geo:
      uvs=_collect_uvs_from_geo(geo)
      if uvs:
        _debug('uv size: uv count ' + str(len(uvs)))
        min_idx, max_idx=_compute_range(uvs)
        if _apply_range(min_idx, max_idx):
          return
      else:
        _debug('uv size: uv attribute not found on geometry')

    _debug('uv size: WriteGeo fallback disabled')
    return
  finally:
    if current_group and current_group is not root:
      current_group.begin()

def _collect_rig_data(rig):\n  cam_knobs=['projection_mode','focal','haperture','vaperture','near','far','win_translate','win_scale','winroll','focal_point','fstop','translate','rotate','scaling']\n  cam_data=\{\}\n  tgt_translate=None\n  if not hasattr(rig, 'begin'):\n    return cam_data, tgt_translate\n  rig.begin()\n  try:\n    cams=[node for node in nuke.allNodes() if node.Class() in ('Camera3','Camera2','Camera') and node.name().startswith('Cam')]\n    for cam in cams:\n      values=\{\}\n      for k in cam_knobs:\n        if k in cam.knobs():\n          try:\n            values[k]=cam[k].value()\n          except Exception:\n            pass\n      cam_data[cam.name()]=values\n    tgt=nuke.toNode('Target')\n    if tgt and 'translate' in tgt.knobs():\n      try:\n        tgt_translate=tgt['translate'].value()\n      except Exception:\n        tgt_translate=None\n  finally:\n    rig.end()\n  return cam_data, tgt_translate\n\ndef _update_cameras(group, rig):\n  cam_data, tgt_translate=_collect_rig_data(rig)\n  if not cam_data:\n    nuke.message('Charon_Coverage_Rig has no cameras named Cam*.')\n    return\n  group.begin()\n  try:\n    for name, values in cam_data.items():\n      cam=nuke.toNode(name)\n      if not cam:\n        continue\n      for k, v in values.items():\n        if k in cam.knobs():\n          try:\n            cam[k].setValue(v)\n          except Exception:\n            pass\n    if tgt_translate is not None:\n      tgt=nuke.toNode('Target')\n      if tgt and 'translate' in tgt.knobs():\n        try:\n          tgt['translate'].setValue(tgt_translate)\n        except Exception:\n          pass\n  finally:\n    group.end()\n\nrig_input=n.input(1)\nrig=_resolve(rig_input)\n_debug('resolved rig: \{0\} (\{1\})'.format(rig.name() if rig else 'None', rig.Class() if rig else 'None'))\nif not rig:\n  nuke.message('Please connect Charon_Coverage_Rig (Input 2)')\n  raise SystemExit\nif not hasattr(rig, 'begin'):\n  nuke.message('Charon_Coverage_Rig must be a Group/Gizmo node')\n  raise SystemExit\n\n_update_rig_camera_count(n, rig)\nrig_cam_count=_collect_rig_cam_count(rig)\ncurrent_cam_count=_current_cam_count(n)\n_debug('rig_cam_count=\{0\} current_cam_count=\{1\}'.format(rig_cam_count, current_cam_count))\nif rig_cam_count and current_cam_count and rig_cam_count != current_cam_count:\n  new_group=_rebuild_for_count(n, rig_cam_count)\n  if new_group:\n    n=new_group\n    rig=_resolve(n.input(1))\n    _update_rig_camera_count(n, rig)\n\n_update_cameras(n, rig)\ngeo_input=n.input(2)\nif geo_input:\n  _update_uv_size(n, geo_input)\n  _update_geo(n, geo_input)\n"}
 addUserKnob {3 charon_rig_cam_count l "Projection Cameras Found" +DISABLED}
 charon_rig_cam_count 0
 addUserKnob {26 ""}
 addUserKnob {26 output_setting l "OUTPUT SETTINGS"}
 addUserKnob {1 asset_name l "Asset Name"}
 addUserKnob {1 subname l "Sub Name"}
 addUserKnob {7 bake_resolution l "Bake Resolution"}
 bake_resolution 2048
 addUserKnob {22 debug_resolution l "Debug Resolution" -STARTLINE T "n=nuke.thisNode()\nimport nuke\nroot=nuke.root()\ntry:\n  res=int(n['bake_resolution'].value())\nexcept Exception:\n  nuke.message('Bake Resolution must be a number')\n  raise SystemExit\nname='bake_{0}'.format(res)\nfmt_string='{0} {0} 0 0 {0} {0} 1 {1}'.format(res, name)\ntry:\n  nuke.addFormat(fmt_string)\nexcept Exception:\n  pass\ntry:\n  for f in nuke.formats():\n    if f.name()==name:\n      root['format'].setValue(f)\n      raise SystemExit\nexcept SystemExit:\n  pass\nexcept Exception:\n  pass\ntry:\n  root['format'].setValue(name)\nexcept Exception:\n  pass\n"}
 addUserKnob {6 aces_mode l "ACES Mode" +STARTLINE}
 aces_mode true
 addUserKnob {26 path_preview l "Preview Path" T //buck/work/current/LIGHTHOUSE_LOBSTER_ROLL_ANCME-L0001/Production/MAYA/sourceimages/work.kien/_CHARON/}
  addUserKnob {22 write l "Bake Texture" T "import os\nimport nuke\n\nn = nuke.thisNode()\n\ntry:\n    template_dir = n[\"charon_template_dir\"].value()\nexcept Exception:\n    template_dir = \"\"\n\nif not template_dir:\n    nuke.message(\"Template directory missing.\")\nelse:\n    script_path = os.path.join(template_dir, \"projection_texture_bake_bake.py\")\n    if not os.path.exists(script_path):\n        nuke.message(\"Bake script missing: \" + script_path)\n    else:\n        globals_dict = dict(__name__=\"__main__\", nuke=nuke)\n        exec(open(script_path, \"r\").read(), globals_dict)\n" +STARTLINE}
addUserKnob {22 open_folder l "Open Output Location" -STARTLINE T "n=nuke.thisNode()\nimport os, getpass, subprocess\nasset = n\['asset_name'].value()\nsub = n\['subname'].value()\nproject_path = os.environ.get('BUCK_PROJECT_PATH')\nuser = getpass.getuser()\nif not project_path:\n    ref = n.node('Read11')\n    if ref:\n        path = ref\['file'].value().replace('\\\\', '/')\n        if '/Production/' in path:\n            project_path = path.split('/Production/')\[0]\nif project_path:\n    out_dir = os.path.join(project_path, \"Production\", \"MAYA\", \"sourceimages\", \"work.\{\}\".format(user), \"_CHARON\", asset, sub)\n    out_dir_norm = os.path.normpath(out_dir)\n    out_dir_display = out_dir_norm.replace('\\\\', '/')\n    if os.path.exists(out_dir_norm):\n        if os.name == 'nt':\n            os.startfile(out_dir_norm)\n        elif os.name == 'posix':\n            subprocess.Popen(['open', out_dir_norm])\n        else:\n            subprocess.Popen(['xdg-open', out_dir_norm])\n    else:\n        nuke.message('Folder does not exist yet: ' + out_dir_display)\nelse:\n    nuke.message('Could not determine project path.')"}
}
 BackdropNode {
  inputs 0
  name BackdropNode1
  tile_color 0x8e388e00
  label GEO
  note_font_size 42
  xpos -795
  ypos -132
  bdheight 120
 }
 Input {
  inputs 0
  name Charon_Coverage_Rig
  xpos -566
  ypos -29
  number 1
 }
 Axis3 {
  inputs 0
  translate {0 132.3999939 0}
  name Target
  xpos -550
  ypos 158
 }
set N12b75200 [stack 0]
push 0
 Camera3 {
  inputs 2
  translate {0 132.3999939 161.1999969}
  focal 100
  name CamInit
  xpos -550
  ypos 358
 }
set N12b75700 [stack 0]
 Dot {
  name Dot1
  xpos -428
  ypos 382
 }
 Dot {
  name Dot2
  xpos -428
  ypos 699
 }
push $N12b75700
 Input {
  inputs 0
  name Main
  xpos -744
  ypos 291
 }
set N1276f180 [stack 0]
add_layer {projection_CamInit projection_CamInit.red projection_CamInit.green projection_CamInit.blue}
 Shuffle2 {
  fromInput1 {
   {0}
   B
  }
  in1 projection_CamInit
  fromInput2 {
   {0}
   B
  }
  mappings "4 white -1 -1 rgba.alpha 0 3 projection_CamInit.red 0 0 rgba.red 0 0 projection_CamInit.green 0 1 rgba.green 0 1 projection_CamInit.blue 0 2 rgba.blue 0 2"
  name Shuffle1
  xpos -744
  ypos 524
 }
 Project3D2 {
  inputs 2
  project_on front
  crop false
  occlusion_mode world
  name Project3D1
  xpos -560
  ypos 524
 }
 UVTile2 {
  tile_u {{parent.UVcoord.u}}
  tile_v {{parent.UVcoord.v}}
  name UVTile1
  xpos -560
  ypos 548
 }
 set C1772aa00 [stack 0]
 ReadGeo2 {
  file //buck/work/current/LIGHTHOUSE_LOBSTER_ROLL_ANCME-L0001/Production/MAYA/sourceimages/work.kien/_99_CHARON/_TEXTURING/char_teacher/geo/all.abc
  version 13
  sub_frame false
  use_geometry_colors false
  range_first 0
  range_last 801
  cast_shadow false
  receive_shadow false
  scene_view {
   {0}
   imported:
   0
   1
   2
   3
   4
   5
   6
   7
   8
   9
   10
   11
   12
   13
   14
   15
   16
   17
   18
   19
   20
   21
   22
   23
   24
   25
   26
   27
   28
   29
   30
   31
   32
   33
   34
   35
   36
   37
   38
   39
   40
   41
   42
   43
   44
   selected:
   8
   7
   6
   5
   4
   3
   items:
   /root/char_teacher_mdl:GEOgrp/char_teacher_mdl:InnerMouth_Grp/char_teacher_mdl:Tongue_Geo/char_teacher_mdl:Tongue_GeoShape
   /root/char_teacher_mdl:GEOgrp/char_teacher_mdl:InnerMouth_Grp/char_teacher_mdl:LowerTeeth_Geo/char_teacher_mdl:LowerTeeth_GeoShape
   /root/char_teacher_mdl:GEOgrp/char_teacher_mdl:InnerMouth_Grp/char_teacher_mdl:UpperTeeth_Geo/char_teacher_mdl:UpperTeeth_GeoShape
   /root/char_teacher_mdl:GEOgrp/char_teacher_mdl:Eyes_Grp/char_teacher_mdl:Eye_R_Grp/char_teacher_mdl:Eye_R_Geo/char_teacher_mdl:Eye_R_GeoShape
   /root/char_teacher_mdl:GEOgrp/char_teacher_mdl:Eyes_Grp/char_teacher_mdl:Eye_R_Grp/char_teacher_mdl:Duct_R_Geo/char_teacher_mdl:Duct_R_GeoShape
   /root/char_teacher_mdl:GEOgrp/char_teacher_mdl:Eyes_Grp/char_teacher_mdl:Eye_L_Grp/char_teacher_mdl:Eye_L_Geo/char_teacher_mdl:Eye_L_GeoShape
   /root/char_teacher_mdl:GEOgrp/char_teacher_mdl:Eyes_Grp/char_teacher_mdl:Eye_L_Grp/char_teacher_mdl:Duct_L_Geo/char_teacher_mdl:Duct_L_GeoShape
   /root/char_teacher_mdl:GEOgrp/char_teacher_mdl:Eyebrows_Geo/char_teacher_mdl:Eyebrows_GeoShape
   /root/char_teacher_mdl:GEOgrp/char_teacher_mdl:Body_Geo/char_teacher_mdl:Body_GeoShape
   /root/char_teacher_mdl:GEOgrp/char_teacher_mdl:Eyelashes_Geo/char_teacher_mdl:Eyelashes_GeoShape
   /root/char_teacher_mdl:GEOgrp/char_teacher_mdl:Nails_geo/char_teacher_mdl:Nails_geoShape
   /root/char_teacher_mdl:GEOgrp/char_teacher_mdl:Head_Geo/char_teacher_mdl:Head_GeoShape
   /root/char_teacher_mdl:GEOgrp/char_teacher_mdl:Outfits_Grp/char_teacher_mdl:Glasses_Geo/char_teacher_mdl:Glasses_GeoShape
   /root/char_teacher_mdl:GEOgrp/char_teacher_mdl:Outfits_Grp/char_teacher_mdl:Pants_Geo/char_teacher_mdl:Pants_GeoShape
   /root/char_teacher_mdl:GEOgrp/char_teacher_mdl:Outfits_Grp/char_teacher_mdl:Shirt_Geo/char_teacher_mdl:Shirt_GeoShape
   /root/char_teacher_mdl:GEOgrp/char_teacher_mdl:Outfits_Grp/char_teacher_mdl:Jacket_Geo/char_teacher_mdl:Jacket_GeoShape
   /root/char_teacher_mdl:GEOgrp/char_teacher_mdl:Outfits_Grp/char_teacher_mdl:Shoes_Geo_Grp/char_teacher_mdl:Shoelaces_Geo/char_teacher_mdl:Shoelaces_GeoShape
   /root/char_teacher_mdl:GEOgrp/char_teacher_mdl:Outfits_Grp/char_teacher_mdl:Shoes_Geo_Grp/char_teacher_mdl:Shoe_Tertiary_Geo/char_teacher_mdl:Shoe_Tertiary_GeoShape
   /root/char_teacher_mdl:GEOgrp/char_teacher_mdl:Outfits_Grp/char_teacher_mdl:Shoes_Geo_Grp/char_teacher_mdl:Shoe_Tred_Geo/char_teacher_mdl:Shoe_Tred_GeoShape
   /root/char_teacher_mdl:GEOgrp/char_teacher_mdl:Outfits_Grp/char_teacher_mdl:Shoes_Geo_Grp/char_teacher_mdl:Shoe_Secondary_Geo/char_teacher_mdl:Shoe_Secondary_GeoShape
   /root/char_teacher_mdl:GEOgrp/char_teacher_mdl:Outfits_Grp/char_teacher_mdl:Shoes_Geo_Grp/char_teacher_mdl:Shoe_Detail_Geo/char_teacher_mdl:Shoe_Detail_GeoShape
   /root/char_teacher_mdl:GEOgrp/char_teacher_mdl:Outfits_Grp/char_teacher_mdl:Shoes_Geo_Grp/char_teacher_mdl:Shoe_Geo/char_teacher_mdl:Shoe_GeoShape
   /root/char_teacher_mdl:GEOgrp/char_teacher_mdl:Outfits_Grp/char_teacher_mdl:Shoes_Geo_Grp/char_teacher_mdl:Socks_Geo/char_teacher_mdl:Socks_GeoShape
   /root/char_teacher_mdl:GEOgrp/char_teacher_mdl:Outfits_Grp/char_teacher_mdl:Tag_Grp/char_teacher_mdl:Clips_Geo/char_teacher_mdl:Clips_GeoShape
   /root/char_teacher_mdl:GEOgrp/char_teacher_mdl:Outfits_Grp/char_teacher_mdl:Tag_Grp/char_teacher_mdl:Plastic_Geo/char_teacher_mdl:Plastic_GeoShape
   /root/char_teacher_mdl:GEOgrp/char_teacher_mdl:Outfits_Grp/char_teacher_mdl:Tag_Grp/char_teacher_mdl:Tag_Geo/char_teacher_mdl:Tag_GeoShape
   /root/char_teacher_mdl:GEOgrp/char_teacher_mdl:Outfits_Grp/char_teacher_mdl:Accessory_Grp/char_teacher_mdl:Accessory_R_Grp/char_teacher_mdl:Bracelet_beads_R_Geo/char_teacher_mdl:Bracelet_beads_R_GeoShape
   /root/char_teacher_mdl:GEOgrp/char_teacher_mdl:Outfits_Grp/char_teacher_mdl:Accessory_Grp/char_teacher_mdl:Accessory_R_Grp/char_teacher_mdl:Bracelet_R_A_Geo/char_teacher_mdl:Bracelet_R_A_GeoShape
   /root/char_teacher_mdl:GEOgrp/char_teacher_mdl:Outfits_Grp/char_teacher_mdl:Accessory_Grp/char_teacher_mdl:Accessory_R_Grp/char_teacher_mdl:Ring_C_Geo/char_teacher_mdl:Ring_C_GeoShape
   /root/char_teacher_mdl:GEOgrp/char_teacher_mdl:Outfits_Grp/char_teacher_mdl:Accessory_Grp/char_teacher_mdl:Accessory_L_Grp/char_teacher_mdl:Bracelet_L_C_Geo/char_teacher_mdl:Bracelet_L_C_GeoShape
   /root/char_teacher_mdl:GEOgrp/char_teacher_mdl:Outfits_Grp/char_teacher_mdl:Accessory_Grp/char_teacher_mdl:Accessory_L_Grp/char_teacher_mdl:Bracelet_L_B_Geo/char_teacher_mdl:Bracelet_L_B_GeoShape
   /root/char_teacher_mdl:GEOgrp/char_teacher_mdl:Outfits_Grp/char_teacher_mdl:Accessory_Grp/char_teacher_mdl:Accessory_L_Grp/char_teacher_mdl:Bracelet_L_A_Geo/char_teacher_mdl:Bracelet_L_A_GeoShape
   /root/char_teacher_mdl:GEOgrp/char_teacher_mdl:Outfits_Grp/char_teacher_mdl:Accessory_Grp/char_teacher_mdl:Accessory_L_Grp/char_teacher_mdl:Bracelet_beads_L_Geo/char_teacher_mdl:Bracelet_beads_L_GeoShape
   /root/char_teacher_mdl:GEOgrp/char_teacher_mdl:Outfits_Grp/char_teacher_mdl:Accessory_Grp/char_teacher_mdl:Accessory_L_Grp/char_teacher_mdl:Ring_B_Geo/char_teacher_mdl:Ring_B_GeoShape
   /root/char_teacher_mdl:GEOgrp/char_teacher_mdl:Outfits_Grp/char_teacher_mdl:Accessory_Grp/char_teacher_mdl:Accessory_L_Grp/char_teacher_mdl:Ring_A_Geo/char_teacher_mdl:Ring_A_GeoShape
   /root/char_teacher_mdl:GEOgrp/char_teacher_mdl:Outfits_Grp/char_teacher_mdl:Accessory_Grp/char_teacher_mdl:necklace_A_Grp/char_teacher_mdl:Beads_A_Geo/char_teacher_mdl:Beads_A_GeoShape
   /root/char_teacher_mdl:GEOgrp/char_teacher_mdl:Outfits_Grp/char_teacher_mdl:Accessory_Grp/char_teacher_mdl:necklace_A_Grp/char_teacher_mdl:String_A_Geo/char_teacher_mdl:String_A_GeoShape
   /root/char_teacher_mdl:GEOgrp/char_teacher_mdl:Outfits_Grp/char_teacher_mdl:Accessory_Grp/char_teacher_mdl:Earring_Geo/char_teacher_mdl:Earring_GeoShape
   /root/char_teacher_mdl:GEOgrp/char_teacher_mdl:Outfits_Grp/char_teacher_mdl:Accessory_Grp/char_teacher_mdl:necklace_B_Grp/char_teacher_mdl:String_B_Geo/char_teacher_mdl:String_B_GeoShape
   /root/char_teacher_mdl:GEOgrp/char_teacher_mdl:Outfits_Grp/char_teacher_mdl:Accessory_Grp/char_teacher_mdl:necklace_B_Grp/char_teacher_mdl:Beads_B_Geo/char_teacher_mdl:Beads_B_GeoShape
   /root/char_teacher_mdl:GEOgrp/char_teacher_mdl:Outfits_Grp/char_teacher_mdl:Accessory_Grp/char_teacher_mdl:Hair_Clip_A_Geo/char_teacher_mdl:Hair_Clip_A_GeoShape
   /root/char_teacher_mdl:GEOgrp/char_teacher_mdl:Outfits_Grp/char_teacher_mdl:Accessory_Grp/char_teacher_mdl:Hair_Clip_B_Geo/char_teacher_mdl:Hair_Clip_B_GeoShape
   /root/char_teacher_mdl:GEOgrp/char_teacher_mdl:Hair_Grp/char_teacher_mdl:InnerHair_Geo/char_teacher_mdl:InnerHair_Geo2Shape
   /root/char_teacher_mdl:GEOgrp/char_teacher_mdl:Hair_Grp/char_teacher_mdl:Hair_Geo/char_teacher_mdl:Hair_GeoShape
   /root/char_teacher_mdl:GEOgrp/char_teacher_mdl:Hair_Grp/char_teacher_mdl:Flyaway_Geo/char_teacher_mdl:Flyaway_GeoShape
  }
  name ReadGeo2
  xpos -560
  ypos 602
 }
 set C1772af00 [stack 0]
push 0
add_layer {N N.red N.green N.blue}
 ScanlineRender {
  inputs 3
  conservative_shader_sampling false
  antialiasing high
  projection_mode uv
  motion_vectors_type off
  output_shader_vectors true
  N_channel N
  name ScanlineRender1
  xpos -560
  ypos 696
 }
 set C1772b400 [stack 0]
 Dot {
  name Dot38
  xpos -526
  ypos 765
 }
set N12b5bc00 [stack 0]
 Group {
  name NormalsRotate12
  onCreate "\nn=nuke.thisNode()\nn\['mblack'].setFlag(0x0000000000000004)\nn\['mgain'].setFlag(0x0000000000000004)\nn\['mgamma'].setFlag(0x0000000000000004)\n"
  tile_color 0xff00ff
  xpos 3332
  ypos 762
  addUserKnob {20 User}
  addUserKnob {41 in l "Normals in" t "Select the layer containing the \nnormals" T Shuffle1.in}
  addUserKnob {41 pick l "Pick Plane" T Plane.pick}
  addUserKnob {22 planereset l Reset -STARTLINE T "nuke.thisNode().knob(\"pick\").setValue(0,0)\nnuke.thisNode().knob(\"pick\").setValue(0,1)\nnuke.thisNode().knob(\"pick\").setValue(1,2)"}
  addUserKnob {26 ""}
  addUserKnob {26 divider_2 l "" +STARTLINE T " "}
  addUserKnob {26 manual l "<b>Manual Rotation</b>" -STARTLINE T "  "}
  addUserKnob {22 rotreset l Reset -STARTLINE T "nuke.thisNode().knob(\"yoffset\").setValue(0)\nnuke.thisNode().knob(\"xzrot\").setValue(0)"}
  addUserKnob {7 yoffset l Horizontal t "Rotate around the world Y axis" R -180 180}
  yoffset {{"degrees(atan2(CamInit.world_matrix.2, CamInit.world_matrix.10))"}}
  addUserKnob {7 xzrot l Vertical t "Rotates around the rotated X axis" R -180 180}
  addUserKnob {26 ""}
  addUserKnob {26 matte l "@b;Matte Output" T "      "}
  addUserKnob {6 inv l "Invert    " t "This happens before the matte \ntweaks" -STARTLINE}
  addUserKnob {6 amask l "Mask by Alpha    " -STARTLINE}
  amask true
  addUserKnob {6 unpre l Unpremult -STARTLINE}
  addUserKnob {7 exp l Exponent t "Exponential falloff" R 1 10}
  exp 2
  addUserKnob {22 expreset l Reset -STARTLINE T "nuke.thisNode().knob(\"exp\").setValue(2)"}
  addUserKnob {7 mblack l Black R -1 1}
  mblack 0.42
  addUserKnob {22 mblackreset l Reset -STARTLINE T "nuke.thisNode().knob(\"mblack\").setValue(0)"}
  addUserKnob {7 mgain l White R 0 4}
  mgain 4
  addUserKnob {22 mgainreset l Reset -STARTLINE T "nuke.thisNode().knob(\"mgain\").setValue(1)"}
  addUserKnob {7 mgamma l Gamma R 0 4}
  mgamma 1
  addUserKnob {22 mgammareset l Reset -STARTLINE T "nuke.thisNode().knob(\"mgamma\").setValue(1)"}
  addUserKnob {26 ""}
  addUserKnob {26 "" l mask T ""}
  addUserKnob {41 maskChannelInput l "" -STARTLINE T Merge1.maskChannelInput}
  addUserKnob {41 inject -STARTLINE T Merge1.inject}
  addUserKnob {41 invert_mask l invert -STARTLINE T Merge1.invert_mask}
  addUserKnob {41 fringe -STARTLINE T Merge1.fringe}
  addUserKnob {41 mix T Merge1.mix}
  addUserKnob {20 info l Info}
  addUserKnob {26 infotext l "" +STARTLINE T "W_SuperNormal generates a surface angle based matte using normals.\n\n1. Select the layer containing normals in the dropdown menu.\n2. Enable color picker and pick the point where you want the matte to be white.\n  (I look at the alpha output, hold ctrl+alt and \"glide\" over the surfaces.)\n3. You can also manually rotate the matte. When you colorpick a new point,\n  it is recommended that you reset the manual rotation values to 0.\n"}
  addUserKnob {20 v2_1_group l "v2.1 - Feb 2019" n 1}
  v2_1_group 0
  addUserKnob {26 v2_1_text l "" +STARTLINE T "  -Manual rotation working as originally envisioned: It is more intuitive \n   and faster to reach any desired angle with horizontal(Y) and vertical\n   rotation than with separate XYZ rotations.\n  -General cleanup & refinements.\n"}
  addUserKnob {20 endGroup n -1}
  addUserKnob {20 v2group l "v2.0 - 2018" n 1}
  v2group 0
  addUserKnob {26 v2text l "" +STARTLINE T "  -Adopted a different method for rotating normals shown to me by Daniel Pelc\n  -Simpler math for converting normals into a matte with the help of Erwan Leroy\n"}
  addUserKnob {20 endGroup_1 l endGroup n -1}
  addUserKnob {26 v1_1_text l "" +STARTLINE T "    v1.1 - 2016"}
  addUserKnob {26 ""}
  addUserKnob {26 spacer_1 l "" +STARTLINE T "     "}
  addUserKnob {26 copyright l "&#169;  Wes Heo" -STARTLINE T " "}
 }
  Axis2 {
   inputs 0
   rot_order YXZ
   rotate {0 {-parent.yoffset} 0}
   name Axis10
   label H
   xpos -173
   ypos -163
  }
  Axis2 {
   inputs 0
   rot_order YXZ
   rotate {{parent.xzrot} {-degrees(parent.Plane.picked.g)} 0}
   name Axis2
   label V
   xpos -171
   ypos -62
  }
  Axis2 {
   inputs 0
   rot_order YXZ
   rotate {0 {-parent.Axis2.rotate.y} 0}
   name Axis5
   label V
   xpos -170
   ypos 34
  }
  Input {
   inputs 0
   name Inputmask
   xpos 132
   ypos 544
   number 1
  }
  Input {
   inputs 0
   name N
   xpos 0
   ypos -425
  }
  Shuffle {
   in N
   alpha red2
   out rgb
   name Shuffle1
   xpos 0
   ypos -347
  }
set N1772cd00 [stack 0]
  Dot {
   name Dot1
   xpos 315
   ypos 289
  }
push $N1772cd00
  Unpremult {
   name Unpremult1
   xpos 0
   ypos -286
   disable {{!parent.unpre}}
  }
  NoOp {
   name Plane
   xpos 0
   ypos -218
   addUserKnob {20 User}
   addUserKnob {18 pick l "User Picked Plane" R -1 1}
   pick {0 0 1}
   addUserKnob {6 pick_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {20 calc l "Internal Conversions"}
   addUserKnob {18 picked}
   picked {0 {"(atan2(pick.r, pick.b))"} 0}
   addUserKnob {6 picked_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
  }
  ColorMatrix {
   matrix {
    
        {{parent.Axis10.world_matrix.0} {parent.Axis10.world_matrix.1} {parent.Axis10.world_matrix.2}}
        {{parent.Axis10.world_matrix.4} {parent.Axis10.world_matrix.5} {parent.Axis10.world_matrix.6}}
        {{parent.Axis10.world_matrix.8} {parent.Axis10.world_matrix.9} {parent.Axis10.world_matrix.10}}
   }
   name ColorMatrix2
   xpos 0
   ypos -148
   disable {{parent.yoffset==0}}
  }
  ColorMatrix {
   matrix {
    
        {{parent.Axis2.world_matrix.0} {parent.Axis2.world_matrix.1} {parent.Axis2.world_matrix.2}}
        {{parent.Axis2.world_matrix.4} {parent.Axis2.world_matrix.5} {parent.Axis2.world_matrix.6}}
        {{parent.Axis2.world_matrix.8} {parent.Axis2.world_matrix.9} {parent.Axis2.world_matrix.10}}
   }
   name ColorMatrix3
   xpos 0
   ypos -42
   disable {{parent.xzrot==0}}
  }
  ColorMatrix {
   matrix {
    
        {{parent.Axis5.world_matrix.0} {parent.Axis5.world_matrix.1} {parent.Axis5.world_matrix.2}}
        {{parent.Axis5.world_matrix.4} {parent.Axis5.world_matrix.5} {parent.Axis5.world_matrix.6}}
        {{parent.Axis5.world_matrix.8} {parent.Axis5.world_matrix.9} {parent.Axis5.world_matrix.10}}
   }
   name ColorMatrix5
   xpos 0
   ypos 54
   disable {{parent.xzrot==0}}
  }
  Expression {
   temp_name0 nx
   temp_expr0 parent.Plane.pick.r
   temp_name1 ny
   temp_expr1 parent.Plane.pick.g
   temp_name2 nz
   temp_expr2 parent.Plane.pick.b
   channel0 {rgba.red -rgba.green -rgba.blue -rgba.alpha}
   expr0 r*nx
   channel1 {-rgba.red rgba.green -rgba.blue none}
   expr1 g*ny
   channel2 {-rgba.red -rgba.green rgba.blue none}
   expr2 b*nz
   channel3 {none none none -rgba.alpha}
   name Expression1
   xpos 0
   ypos 121
   cached true
  }
  Expression {
   expr3 clamp(r+g+b)
   name Expression3
   xpos 0
   ypos 187
  }
  Invert {
   channels alpha
   name Invert1
   xpos 0
   ypos 249
   disable {{!parent.inv}}
  }
  Expression {
   expr3 pow(a,max(1,parent.exp))
   name Expression4
   xpos 0
   ypos 317
  }
  Grade {
   channels alpha
   blackpoint {{-parent.mblack}}
   white {{parent.mgain}}
   gamma {{max(0.001,parent.mgamma)}}
   white_clamp true
   name Grade1
   xpos 0
   ypos 369
  }
  ChannelMerge {
   inputs 2
   operation multiply
   name ChannelMerge1
   xpos 0
   ypos 444
   disable {{!parent.amask}}
  }
push 0
  Merge2 {
   inputs 2+1
   operation copy
   also_merge all
   name Merge1
   label "\[ expr \{ \[value mix] == 1 ? \" \" : \[concat Mix: \[value mix]] \}]"
   xpos 0
   ypos 544
  }
  Output {
   name Output1
   xpos 0
   ypos 623
  }
 end_group
 FilterErode {
  channels all
  size -58
  name FilterErode1
  xpos 3332
  ypos 1101
 }
 Blur {
  size 20
  name Blur1
  xpos 3240
  ypos 1101
 }
push $N12b75200
push 0
 Camera3 {
  inputs 2
  translate {-1.974130603e-14 132.3999939 -161.1999969}
  focal 100
  name Cam180
  xpos 3044
  ypos 338
 }
set N177e4800 [stack 0]
 Dot {
  name Dot14
  xpos 3165
  ypos 362
 }
 Dot {
  name Dot15
  xpos 3165
  ypos 679
 }
push $N177e4800
push $N1276f180
add_layer {projection_Cam180 projection_Cam180.red projection_Cam180.green projection_Cam180.blue}
 Shuffle2 {
  fromInput1 {
   {0}
   B
  }
  in1 projection_Cam180
  fromInput2 {
   {0}
   B
  }
  mappings "4 projection_Cam180.red 0 0 rgba.red 0 0 projection_Cam180.green 0 1 rgba.green 0 1 projection_Cam180.blue 0 2 rgba.blue 0 2 white -1 -1 rgba.alpha 0 3"
  name Shuffle4
  xpos 2918
  ypos 502
 }
 Project3D2 {
  inputs 2
  project_on front
  occlusion_mode world
  name Project3D5
  xpos 3034
  ypos 502
 }
clone $C1772aa00 {
  xpos 3034
  ypos 539
  selected false
 }
clone $C1772af00 {
  xpos 3033
  ypos 592
  selected false
 }
push 0
clone $C1772b400 {
  inputs 3
  xpos 3033
  ypos 676
  selected false
 }
 Dot {
  name Dot16
  xpos 3068
  ypos 1049
 }
set N17797800 [stack 0]
 Group {
  name NormalsRotate5
  onCreate "\nn=nuke.thisNode()\nn\['mblack'].setFlag(0x0000000000000004)\nn\['mgain'].setFlag(0x0000000000000004)\nn\['mgamma'].setFlag(0x0000000000000004)\n"
  tile_color 0xff00ff
  xpos 3130
  ypos 1046
  addUserKnob {20 User}
  addUserKnob {41 in l "Normals in" t "Select the layer containing the \nnormals" T Shuffle1.in}
  addUserKnob {41 pick l "Pick Plane" T Plane.pick}
  addUserKnob {22 planereset l Reset -STARTLINE T "nuke.thisNode().knob(\"pick\").setValue(0,0)\nnuke.thisNode().knob(\"pick\").setValue(0,1)\nnuke.thisNode().knob(\"pick\").setValue(1,2)"}
  addUserKnob {26 ""}
  addUserKnob {26 divider_2 l "" +STARTLINE T " "}
  addUserKnob {26 manual l "<b>Manual Rotation</b>" -STARTLINE T "  "}
  addUserKnob {22 rotreset l Reset -STARTLINE T "nuke.thisNode().knob(\"yoffset\").setValue(0)\nnuke.thisNode().knob(\"xzrot\").setValue(0)"}
  addUserKnob {7 yoffset l Horizontal t "Rotate around the world Y axis" R -180 180}
  yoffset {{"degrees(atan2(Cam180.world_matrix.2, Cam180.world_matrix.10))"}}
  addUserKnob {7 xzrot l Vertical t "Rotates around the rotated X axis" R -180 180}
  xzrot -15
  addUserKnob {26 ""}
  addUserKnob {26 matte l "@b;Matte Output" T "      "}
  addUserKnob {6 inv l "Invert    " t "This happens before the matte \ntweaks" -STARTLINE}
  addUserKnob {6 amask l "Mask by Alpha    " -STARTLINE}
  amask true
  addUserKnob {6 unpre l Unpremult -STARTLINE}
  addUserKnob {7 exp l Exponent t "Exponential falloff" R 1 10}
  exp 2.2
  addUserKnob {22 expreset l Reset -STARTLINE T "nuke.thisNode().knob(\"exp\").setValue(2)"}
  addUserKnob {7 mblack l Black R -1 1}
  addUserKnob {22 mblackreset l Reset -STARTLINE T "nuke.thisNode().knob(\"mblack\").setValue(0)"}
  addUserKnob {7 mgain l White R 0 4}
  mgain 4
  addUserKnob {22 mgainreset l Reset -STARTLINE T "nuke.thisNode().knob(\"mgain\").setValue(1)"}
  addUserKnob {7 mgamma l Gamma R 0 4}
  mgamma 1
  addUserKnob {22 mgammareset l Reset -STARTLINE T "nuke.thisNode().knob(\"mgamma\").setValue(1)"}
  addUserKnob {26 ""}
  addUserKnob {26 "" l mask T ""}
  addUserKnob {41 maskChannelInput l "" -STARTLINE T Merge1.maskChannelInput}
  addUserKnob {41 inject -STARTLINE T Merge1.inject}
  addUserKnob {41 invert_mask l invert -STARTLINE T Merge1.invert_mask}
  addUserKnob {41 fringe -STARTLINE T Merge1.fringe}
  addUserKnob {41 mix T Merge1.mix}
  addUserKnob {20 info l Info}
  addUserKnob {26 infotext l "" +STARTLINE T "W_SuperNormal generates a surface angle based matte using normals.\n\n1. Select the layer containing normals in the dropdown menu.\n2. Enable color picker and pick the point where you want the matte to be white.\n  (I look at the alpha output, hold ctrl+alt and \"glide\" over the surfaces.)\n3. You can also manually rotate the matte. When you colorpick a new point,\n  it is recommended that you reset the manual rotation values to 0.\n"}
  addUserKnob {20 v2_1_group l "v2.1 - Feb 2019" n 1}
  v2_1_group 0
  addUserKnob {26 v2_1_text l "" +STARTLINE T "  -Manual rotation working as originally envisioned: It is more intuitive \n   and faster to reach any desired angle with horizontal(Y) and vertical\n   rotation than with separate XYZ rotations.\n  -General cleanup & refinements.\n"}
  addUserKnob {20 endGroup n -1}
  addUserKnob {20 v2group l "v2.0 - 2018" n 1}
  v2group 0
  addUserKnob {26 v2text l "" +STARTLINE T "  -Adopted a different method for rotating normals shown to me by Daniel Pelc\n  -Simpler math for converting normals into a matte with the help of Erwan Leroy\n"}
  addUserKnob {20 endGroup_1 l endGroup n -1}
  addUserKnob {26 v1_1_text l "" +STARTLINE T "    v1.1 - 2016"}
  addUserKnob {26 ""}
  addUserKnob {26 spacer_1 l "" +STARTLINE T "     "}
  addUserKnob {26 copyright l "&#169;  Wes Heo" -STARTLINE T " "}
 }
  Axis2 {
   inputs 0
   rot_order YXZ
   rotate {0 {-parent.yoffset} 0}
   name Axis10
   label H
   xpos -173
   ypos -163
  }
  Axis2 {
   inputs 0
   rot_order YXZ
   rotate {{parent.xzrot} {-degrees(parent.Plane.picked.g)} 0}
   name Axis2
   label V
   xpos -171
   ypos -62
  }
  Axis2 {
   inputs 0
   rot_order YXZ
   rotate {0 {-parent.Axis2.rotate.y} 0}
   name Axis5
   label V
   xpos -170
   ypos 34
  }
  Input {
   inputs 0
   name Inputmask
   xpos 132
   ypos 544
   number 1
  }
  Input {
   inputs 0
   name N
   xpos 0
   ypos -425
  }
  Shuffle {
   in N
   alpha red2
   out rgb
   name Shuffle1
   xpos 0
   ypos -347
  }
set N1614fe00 [stack 0]
  Dot {
   name Dot1
   xpos 315
   ypos 289
  }
push $N1614fe00
  Unpremult {
   name Unpremult1
   xpos 0
   ypos -286
   disable {{!parent.unpre}}
  }
  NoOp {
   name Plane
   xpos 0
   ypos -218
   addUserKnob {20 User}
   addUserKnob {18 pick l "User Picked Plane" R -1 1}
   pick {0 0 1}
   addUserKnob {6 pick_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {20 calc l "Internal Conversions"}
   addUserKnob {18 picked}
   picked {0 {"(atan2(pick.r, pick.b))"} 0}
   addUserKnob {6 picked_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
  }
  ColorMatrix {
   matrix {
    
        {{parent.Axis10.world_matrix.0} {parent.Axis10.world_matrix.1} {parent.Axis10.world_matrix.2}}
        {{parent.Axis10.world_matrix.4} {parent.Axis10.world_matrix.5} {parent.Axis10.world_matrix.6}}
        {{parent.Axis10.world_matrix.8} {parent.Axis10.world_matrix.9} {parent.Axis10.world_matrix.10}}
   }
   name ColorMatrix2
   xpos 0
   ypos -148
   disable {{parent.yoffset==0}}
  }
  ColorMatrix {
   matrix {
    
        {{parent.Axis2.world_matrix.0} {parent.Axis2.world_matrix.1} {parent.Axis2.world_matrix.2}}
        {{parent.Axis2.world_matrix.4} {parent.Axis2.world_matrix.5} {parent.Axis2.world_matrix.6}}
        {{parent.Axis2.world_matrix.8} {parent.Axis2.world_matrix.9} {parent.Axis2.world_matrix.10}}
   }
   name ColorMatrix3
   xpos 0
   ypos -42
   disable {{parent.xzrot==0}}
  }
  ColorMatrix {
   matrix {
    
        {{parent.Axis5.world_matrix.0} {parent.Axis5.world_matrix.1} {parent.Axis5.world_matrix.2}}
        {{parent.Axis5.world_matrix.4} {parent.Axis5.world_matrix.5} {parent.Axis5.world_matrix.6}}
        {{parent.Axis5.world_matrix.8} {parent.Axis5.world_matrix.9} {parent.Axis5.world_matrix.10}}
   }
   name ColorMatrix5
   xpos 0
   ypos 54
   disable {{parent.xzrot==0}}
  }
  Expression {
   temp_name0 nx
   temp_expr0 parent.Plane.pick.r
   temp_name1 ny
   temp_expr1 parent.Plane.pick.g
   temp_name2 nz
   temp_expr2 parent.Plane.pick.b
   channel0 {rgba.red -rgba.green -rgba.blue -rgba.alpha}
   expr0 r*nx
   channel1 {-rgba.red rgba.green -rgba.blue none}
   expr1 g*ny
   channel2 {-rgba.red -rgba.green rgba.blue none}
   expr2 b*nz
   channel3 {none none none -rgba.alpha}
   name Expression1
   xpos 0
   ypos 121
   cached true
  }
  Expression {
   expr3 clamp(r+g+b)
   name Expression3
   xpos 0
   ypos 187
  }
  Invert {
   channels alpha
   name Invert1
   xpos 0
   ypos 249
   disable {{!parent.inv}}
  }
  Expression {
   expr3 pow(a,max(1,parent.exp))
   name Expression4
   xpos 0
   ypos 317
  }
  Grade {
   channels alpha
   blackpoint {{-parent.mblack}}
   white {{parent.mgain}}
   gamma {{max(0.001,parent.mgamma)}}
   white_clamp true
   name Grade1
   xpos 0
   ypos 369
  }
  ChannelMerge {
   inputs 2
   operation multiply
   name ChannelMerge1
   xpos 0
   ypos 444
   disable {{!parent.amask}}
  }
push 0
  Merge2 {
   inputs 2+1
   operation copy
   also_merge all
   name Merge1
   label "\[ expr \{ \[value mix] == 1 ? \" \" : \[concat Mix: \[value mix]] \}]"
   xpos 0
   ypos 544
  }
  Output {
   name Output1
   xpos 0
   ypos 623
  }
 end_group
 Grade {
  inputs 1+1
  channels rgba
  white 0
  name Grade10
  xpos 3130
  ypos 1107
 }
push $N17797800
push $N12b75200
push 0
 Camera3 {
  inputs 2
  translate {113.985611 132.3999939 -113.985611}
  focal 100
  name Cam225
  xpos 2628
  ypos 351
 }
set N16209700 [stack 0]
 Dot {
  name Dot23
  xpos 2749
  ypos 375
 }
 Dot {
  name Dot24
  xpos 2749
  ypos 692
 }
push $N16209700
push $N1276f180
add_layer {projection_Cam225 projection_Cam225.red projection_Cam225.green projection_Cam225.blue}
 Shuffle2 {
  fromInput1 {
   {0}
   B
  }
  in1 projection_Cam225
  fromInput2 {
   {0}
   B
  }
  mappings "4 projection_Cam225.red 0 0 rgba.red 0 0 projection_Cam225.green 0 1 rgba.green 0 1 projection_Cam225.blue 0 2 rgba.blue 0 2 white -1 -1 rgba.alpha 0 3"
  name Shuffle5
  xpos 2484
  ypos 515
 }
 Project3D2 {
  inputs 2
  project_on front
  occlusion_mode world
  name Project3D8
  xpos 2618
  ypos 515
 }
clone $C1772aa00 {
  xpos 2618
  ypos 539
  selected false
 }
clone $C1772af00 {
  xpos 2618
  ypos 603
  selected false
 }
push 0
clone $C1772b400 {
  inputs 3
  xpos 2618
  ypos 689
  selected false
 }
 Dot {
  name Dot25
  xpos 2652
  ypos 1062
 }
set N161bf400 [stack 0]
 Group {
  name NormalsRotate8
  onCreate "\nn=nuke.thisNode()\nn\['mblack'].setFlag(0x0000000000000004)\nn\['mgain'].setFlag(0x0000000000000004)\nn\['mgamma'].setFlag(0x0000000000000004)\n"
  tile_color 0xff00ff
  xpos 2708
  ypos 1059
  addUserKnob {20 User}
  addUserKnob {41 in l "Normals in" t "Select the layer containing the \nnormals" T Shuffle1.in}
  addUserKnob {41 pick l "Pick Plane" T Plane.pick}
  addUserKnob {22 planereset l Reset -STARTLINE T "nuke.thisNode().knob(\"pick\").setValue(0,0)\nnuke.thisNode().knob(\"pick\").setValue(0,1)\nnuke.thisNode().knob(\"pick\").setValue(1,2)"}
  addUserKnob {26 ""}
  addUserKnob {26 divider_2 l "" +STARTLINE T " "}
  addUserKnob {26 manual l "<b>Manual Rotation</b>" -STARTLINE T "  "}
  addUserKnob {22 rotreset l Reset -STARTLINE T "nuke.thisNode().knob(\"yoffset\").setValue(0)\nnuke.thisNode().knob(\"xzrot\").setValue(0)"}
  addUserKnob {7 yoffset l Horizontal t "Rotate around the world Y axis" R -180 180}
  yoffset {{"degrees(atan2(Cam225.world_matrix.2, Cam225.world_matrix.10))+15"}}
  addUserKnob {7 xzrot l Vertical t "Rotates around the rotated X axis" R -180 180}
  addUserKnob {26 ""}
  addUserKnob {26 matte l "@b;Matte Output" T "      "}
  addUserKnob {6 inv l "Invert    " t "This happens before the matte \ntweaks" -STARTLINE}
  addUserKnob {6 amask l "Mask by Alpha    " -STARTLINE}
  addUserKnob {6 unpre l Unpremult -STARTLINE}
  addUserKnob {7 exp l Exponent t "Exponential falloff" R 1 10}
  exp 1.25
  addUserKnob {22 expreset l Reset -STARTLINE T "nuke.thisNode().knob(\"exp\").setValue(2)"}
  addUserKnob {7 mblack l Black R -1 1}
  mblack -0.07
  addUserKnob {22 mblackreset l Reset -STARTLINE T "nuke.thisNode().knob(\"mblack\").setValue(0)"}
  addUserKnob {7 mgain l White R 0 4}
  mgain 4
  addUserKnob {22 mgainreset l Reset -STARTLINE T "nuke.thisNode().knob(\"mgain\").setValue(1)"}
  addUserKnob {7 mgamma l Gamma R 0 4}
  mgamma 1
  addUserKnob {22 mgammareset l Reset -STARTLINE T "nuke.thisNode().knob(\"mgamma\").setValue(1)"}
  addUserKnob {26 ""}
  addUserKnob {26 "" l mask T ""}
  addUserKnob {41 maskChannelInput l "" -STARTLINE T Merge1.maskChannelInput}
  addUserKnob {41 inject -STARTLINE T Merge1.inject}
  addUserKnob {41 invert_mask l invert -STARTLINE T Merge1.invert_mask}
  addUserKnob {41 fringe -STARTLINE T Merge1.fringe}
  addUserKnob {41 mix T Merge1.mix}
  addUserKnob {20 info l Info}
  addUserKnob {26 infotext l "" +STARTLINE T "W_SuperNormal generates a surface angle based matte using normals.\n\n1. Select the layer containing normals in the dropdown menu.\n2. Enable color picker and pick the point where you want the matte to be white.\n  (I look at the alpha output, hold ctrl+alt and \"glide\" over the surfaces.)\n3. You can also manually rotate the matte. When you colorpick a new point,\n  it is recommended that you reset the manual rotation values to 0.\n"}
  addUserKnob {20 v2_1_group l "v2.1 - Feb 2019" n 1}
  v2_1_group 0
  addUserKnob {26 v2_1_text l "" +STARTLINE T "  -Manual rotation working as originally envisioned: It is more intuitive \n   and faster to reach any desired angle with horizontal(Y) and vertical\n   rotation than with separate XYZ rotations.\n  -General cleanup & refinements.\n"}
  addUserKnob {20 endGroup n -1}
  addUserKnob {20 v2group l "v2.0 - 2018" n 1}
  v2group 0
  addUserKnob {26 v2text l "" +STARTLINE T "  -Adopted a different method for rotating normals shown to me by Daniel Pelc\n  -Simpler math for converting normals into a matte with the help of Erwan Leroy\n"}
  addUserKnob {20 endGroup_1 l endGroup n -1}
  addUserKnob {26 v1_1_text l "" +STARTLINE T "    v1.1 - 2016"}
  addUserKnob {26 ""}
  addUserKnob {26 spacer_1 l "" +STARTLINE T "     "}
  addUserKnob {26 copyright l "&#169;  Wes Heo" -STARTLINE T " "}
 }
  Axis2 {
   inputs 0
   rot_order YXZ
   rotate {0 {-parent.yoffset} 0}
   name Axis10
   label H
   xpos -173
   ypos -163
  }
  Axis2 {
   inputs 0
   rot_order YXZ
   rotate {{parent.xzrot} {-degrees(parent.Plane.picked.g)} 0}
   name Axis2
   label V
   xpos -171
   ypos -62
  }
  Axis2 {
   inputs 0
   rot_order YXZ
   rotate {0 {-parent.Axis2.rotate.y} 0}
   name Axis5
   label V
   xpos -170
   ypos 34
  }
  Input {
   inputs 0
   name Inputmask
   xpos 132
   ypos 544
   number 1
  }
  Input {
   inputs 0
   name N
   xpos 0
   ypos -425
  }
  Shuffle {
   in N
   alpha red2
   out rgb
   name Shuffle1
   xpos 0
   ypos -347
  }
set N16246d00 [stack 0]
  Dot {
   name Dot1
   xpos 315
   ypos 289
  }
push $N16246d00
  Unpremult {
   name Unpremult1
   xpos 0
   ypos -286
   disable {{!parent.unpre}}
  }
  NoOp {
   name Plane
   xpos 0
   ypos -218
   addUserKnob {20 User}
   addUserKnob {18 pick l "User Picked Plane" R -1 1}
   pick {0 0 1}
   addUserKnob {6 pick_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {20 calc l "Internal Conversions"}
   addUserKnob {18 picked}
   picked {0 {"(atan2(pick.r, pick.b))"} 0}
   addUserKnob {6 picked_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
  }
  ColorMatrix {
   matrix {
    
        {{parent.Axis10.world_matrix.0} {parent.Axis10.world_matrix.1} {parent.Axis10.world_matrix.2}}
        {{parent.Axis10.world_matrix.4} {parent.Axis10.world_matrix.5} {parent.Axis10.world_matrix.6}}
        {{parent.Axis10.world_matrix.8} {parent.Axis10.world_matrix.9} {parent.Axis10.world_matrix.10}}
   }
   name ColorMatrix2
   xpos 0
   ypos -148
   disable {{parent.yoffset==0}}
  }
  ColorMatrix {
   matrix {
    
        {{parent.Axis2.world_matrix.0} {parent.Axis2.world_matrix.1} {parent.Axis2.world_matrix.2}}
        {{parent.Axis2.world_matrix.4} {parent.Axis2.world_matrix.5} {parent.Axis2.world_matrix.6}}
        {{parent.Axis2.world_matrix.8} {parent.Axis2.world_matrix.9} {parent.Axis2.world_matrix.10}}
   }
   name ColorMatrix3
   xpos 0
   ypos -42
   disable {{parent.xzrot==0}}
  }
  ColorMatrix {
   matrix {
    
        {{parent.Axis5.world_matrix.0} {parent.Axis5.world_matrix.1} {parent.Axis5.world_matrix.2}}
        {{parent.Axis5.world_matrix.4} {parent.Axis5.world_matrix.5} {parent.Axis5.world_matrix.6}}
        {{parent.Axis5.world_matrix.8} {parent.Axis5.world_matrix.9} {parent.Axis5.world_matrix.10}}
   }
   name ColorMatrix5
   xpos 0
   ypos 54
   disable {{parent.xzrot==0}}
  }
  Expression {
   temp_name0 nx
   temp_expr0 parent.Plane.pick.r
   temp_name1 ny
   temp_expr1 parent.Plane.pick.g
   temp_name2 nz
   temp_expr2 parent.Plane.pick.b
   channel0 {rgba.red -rgba.green -rgba.blue -rgba.alpha}
   expr0 r*nx
   channel1 {-rgba.red rgba.green -rgba.blue none}
   expr1 g*ny
   channel2 {-rgba.red -rgba.green rgba.blue none}
   expr2 b*nz
   channel3 {none none none -rgba.alpha}
   name Expression1
   xpos 0
   ypos 121
   cached true
  }
  Expression {
   expr3 clamp(r+g+b)
   name Expression3
   xpos 0
   ypos 187
  }
  Invert {
   channels alpha
   name Invert1
   xpos 0
   ypos 249
   disable {{!parent.inv}}
  }
  Expression {
   expr3 pow(a,max(1,parent.exp))
   name Expression4
   xpos 0
   ypos 317
  }
  Grade {
   channels alpha
   blackpoint {{-parent.mblack}}
   white {{parent.mgain}}
   gamma {{max(0.001,parent.mgamma)}}
   white_clamp true
   name Grade1
   xpos 0
   ypos 369
  }
  ChannelMerge {
   inputs 2
   operation multiply
   name ChannelMerge1
   xpos 0
   ypos 444
   disable {{!parent.amask}}
  }
push 0
  Merge2 {
   inputs 2+1
   operation copy
   also_merge all
   name Merge1
   label "\[ expr \{ \[value mix] == 1 ? \" \" : \[concat Mix: \[value mix]] \}]"
   xpos 0
   ypos 544
  }
  Output {
   name Output1
   xpos 0
   ypos 623
  }
 end_group
 FilterErode {
  channels alpha
  size 4.5
  name FilterErode2
  xpos 2708
  ypos 1083
  disable true
 }
 set C162fde00 [stack 0]
push $N161bf400
 Camera3 {
  inputs 0
  name Camera1
  xpos -1167
  ypos 1077
 }
clone $C1772af00 {
  inputs 0
  xpos -1025
  ypos 1001
  selected false
 }
push 0
clone $C1772b400 {
  inputs 3
  xpos -1025
  ypos 1098
  selected false
 }
 Invert {
  name Invert5
  xpos -808
  ypos 1092
 }
set N162ff700 [stack 0]
push $N12b75200
push 0
 Camera3 {
  inputs 2
  translate {113.985611 132.3999939 113.985611}
  focal 100
  name Cam315
  xpos 1665
  ypos 338
 }
set N16362000 [stack 0]
 Dot {
  name Dot17
  xpos 1786
  ypos 362
 }
 Dot {
  name Dot18
  xpos 1786
  ypos 679
 }
push $N16362000
push $N1276f180
add_layer {projection_Cam315 projection_Cam315.red projection_Cam315.green projection_Cam315.blue}
 Shuffle2 {
  fromInput1 {
   {0}
   B
  }
  in1 projection_Cam315
  fromInput2 {
   {0}
   B
  }
  mappings "4 projection_Cam315.red 0 0 rgba.red 0 0 projection_Cam315.green 0 1 rgba.green 0 1 projection_Cam315.blue 0 2 rgba.blue 0 2 white -1 -1 rgba.alpha 0 3"
  name Shuffle8
  xpos 1545
  ypos 502
 }
 Project3D2 {
  inputs 2
  project_on front
  occlusion_mode world
  name Project3D6
  xpos 1655
  ypos 502
 }
clone $C1772aa00 {
  xpos 1655
  ypos 526
  selected false
 }
clone $C1772af00 {
  xpos 1655
  ypos 593
  selected false
 }
push 0
clone $C1772b400 {
  inputs 3
  xpos 1655
  ypos 676
  selected false
 }
 Dot {
  name Dot44
  xpos 1689
  ypos 917
 }
set N1631d400 [stack 0]
 Dot {
  name Dot45
  xpos 1689
  ypos 964
 }
set N1631d800 [stack 0]
 Invert {
  name Invert4
  xpos 1710
  ypos 955
 }
 Grade {
  inputs 1+1
  channels rgba
  white 0
  name Grade12
  xpos 1796
  ypos 961
 }
 set C16364800 [stack 0]
 Erode {
  channels all
  size -23
  blur 0.365
  name Erode4
  xpos 1876
  ypos 955
 }
push $N1631d400
 Group {
  name NormalsRotate11
  onCreate "\nn=nuke.thisNode()\nn\['mblack'].setFlag(0x0000000000000004)\nn\['mgain'].setFlag(0x0000000000000004)\nn\['mgamma'].setFlag(0x0000000000000004)\n"
  tile_color 0xff00ff
  xpos 1791
  ypos 914
  addUserKnob {20 User}
  addUserKnob {41 in l "Normals in" t "Select the layer containing the \nnormals" T Shuffle1.in}
  addUserKnob {41 pick l "Pick Plane" T Plane.pick}
  addUserKnob {22 planereset l Reset -STARTLINE T "nuke.thisNode().knob(\"pick\").setValue(0,0)\nnuke.thisNode().knob(\"pick\").setValue(0,1)\nnuke.thisNode().knob(\"pick\").setValue(1,2)"}
  addUserKnob {26 ""}
  addUserKnob {26 divider_2 l "" +STARTLINE T " "}
  addUserKnob {26 manual l "<b>Manual Rotation</b>" -STARTLINE T "  "}
  addUserKnob {22 rotreset l Reset -STARTLINE T "nuke.thisNode().knob(\"yoffset\").setValue(0)\nnuke.thisNode().knob(\"xzrot\").setValue(0)"}
  addUserKnob {7 yoffset l Horizontal t "Rotate around the world Y axis" R -180 180}
  yoffset {{"degrees(atan2(Cam315.world_matrix.2, Cam315.world_matrix.10))"}}
  addUserKnob {7 xzrot l Vertical t "Rotates around the rotated X axis" R -180 180}
  addUserKnob {26 ""}
  addUserKnob {26 matte l "@b;Matte Output" T "      "}
  addUserKnob {6 inv l "Invert    " t "This happens before the matte \ntweaks" -STARTLINE}
  addUserKnob {6 amask l "Mask by Alpha    " -STARTLINE}
  amask true
  addUserKnob {6 unpre l Unpremult -STARTLINE}
  addUserKnob {7 exp l Exponent t "Exponential falloff" R 1 10}
  exp 2
  addUserKnob {22 expreset l Reset -STARTLINE T "nuke.thisNode().knob(\"exp\").setValue(2)"}
  addUserKnob {7 mblack l Black R -1 1}
  addUserKnob {22 mblackreset l Reset -STARTLINE T "nuke.thisNode().knob(\"mblack\").setValue(0)"}
  addUserKnob {7 mgain l White R 0 4}
  mgain 2
  addUserKnob {22 mgainreset l Reset -STARTLINE T "nuke.thisNode().knob(\"mgain\").setValue(1)"}
  addUserKnob {7 mgamma l Gamma R 0 4}
  mgamma 1
  addUserKnob {22 mgammareset l Reset -STARTLINE T "nuke.thisNode().knob(\"mgamma\").setValue(1)"}
  addUserKnob {26 ""}
  addUserKnob {26 "" l mask T ""}
  addUserKnob {41 maskChannelInput l "" -STARTLINE T Merge1.maskChannelInput}
  addUserKnob {41 inject -STARTLINE T Merge1.inject}
  addUserKnob {41 invert_mask l invert -STARTLINE T Merge1.invert_mask}
  addUserKnob {41 fringe -STARTLINE T Merge1.fringe}
  addUserKnob {41 mix T Merge1.mix}
  addUserKnob {20 info l Info}
  addUserKnob {26 infotext l "" +STARTLINE T "W_SuperNormal generates a surface angle based matte using normals.\n\n1. Select the layer containing normals in the dropdown menu.\n2. Enable color picker and pick the point where you want the matte to be white.\n  (I look at the alpha output, hold ctrl+alt and \"glide\" over the surfaces.)\n3. You can also manually rotate the matte. When you colorpick a new point,\n  it is recommended that you reset the manual rotation values to 0.\n"}
  addUserKnob {20 v2_1_group l "v2.1 - Feb 2019" n 1}
  v2_1_group 0
  addUserKnob {26 v2_1_text l "" +STARTLINE T "  -Manual rotation working as originally envisioned: It is more intuitive \n   and faster to reach any desired angle with horizontal(Y) and vertical\n   rotation than with separate XYZ rotations.\n  -General cleanup & refinements.\n"}
  addUserKnob {20 endGroup n -1}
  addUserKnob {20 v2group l "v2.0 - 2018" n 1}
  v2group 0
  addUserKnob {26 v2text l "" +STARTLINE T "  -Adopted a different method for rotating normals shown to me by Daniel Pelc\n  -Simpler math for converting normals into a matte with the help of Erwan Leroy\n"}
  addUserKnob {20 endGroup_1 l endGroup n -1}
  addUserKnob {26 v1_1_text l "" +STARTLINE T "    v1.1 - 2016"}
  addUserKnob {26 ""}
  addUserKnob {26 spacer_1 l "" +STARTLINE T "     "}
  addUserKnob {26 copyright l "&#169;  Wes Heo" -STARTLINE T " "}
 }
  Axis2 {
   inputs 0
   rot_order YXZ
   rotate {0 {-parent.yoffset} 0}
   name Axis10
   label H
   xpos -173
   ypos -163
  }
  Axis2 {
   inputs 0
   rot_order YXZ
   rotate {{parent.xzrot} {-degrees(parent.Plane.picked.g)} 0}
   name Axis2
   label V
   xpos -171
   ypos -62
  }
  Axis2 {
   inputs 0
   rot_order YXZ
   rotate {0 {-parent.Axis2.rotate.y} 0}
   name Axis5
   label V
   xpos -170
   ypos 34
  }
  Input {
   inputs 0
   name Inputmask
   xpos 132
   ypos 544
   number 1
  }
  Input {
   inputs 0
   name N
   xpos 0
   ypos -425
  }
  Shuffle {
   in N
   alpha red2
   out rgb
   name Shuffle1
   xpos 0
   ypos -347
  }
set N163be800 [stack 0]
  Dot {
   name Dot1
   xpos 315
   ypos 289
  }
push $N163be800
  Unpremult {
   name Unpremult1
   xpos 0
   ypos -286
   disable {{!parent.unpre}}
  }
  NoOp {
   name Plane
   xpos 0
   ypos -218
   addUserKnob {20 User}
   addUserKnob {18 pick l "User Picked Plane" R -1 1}
   pick {0 0 1}
   addUserKnob {6 pick_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {20 calc l "Internal Conversions"}
   addUserKnob {18 picked}
   picked {0 {"(atan2(pick.r, pick.b))"} 0}
   addUserKnob {6 picked_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
  }
  ColorMatrix {
   matrix {
    
        {{parent.Axis10.world_matrix.0} {parent.Axis10.world_matrix.1} {parent.Axis10.world_matrix.2}}
        {{parent.Axis10.world_matrix.4} {parent.Axis10.world_matrix.5} {parent.Axis10.world_matrix.6}}
        {{parent.Axis10.world_matrix.8} {parent.Axis10.world_matrix.9} {parent.Axis10.world_matrix.10}}
   }
   name ColorMatrix2
   xpos 0
   ypos -148
   disable {{parent.yoffset==0}}
  }
  ColorMatrix {
   matrix {
    
        {{parent.Axis2.world_matrix.0} {parent.Axis2.world_matrix.1} {parent.Axis2.world_matrix.2}}
        {{parent.Axis2.world_matrix.4} {parent.Axis2.world_matrix.5} {parent.Axis2.world_matrix.6}}
        {{parent.Axis2.world_matrix.8} {parent.Axis2.world_matrix.9} {parent.Axis2.world_matrix.10}}
   }
   name ColorMatrix3
   xpos 0
   ypos -42
   disable {{parent.xzrot==0}}
  }
  ColorMatrix {
   matrix {
    
        {{parent.Axis5.world_matrix.0} {parent.Axis5.world_matrix.1} {parent.Axis5.world_matrix.2}}
        {{parent.Axis5.world_matrix.4} {parent.Axis5.world_matrix.5} {parent.Axis5.world_matrix.6}}
        {{parent.Axis5.world_matrix.8} {parent.Axis5.world_matrix.9} {parent.Axis5.world_matrix.10}}
   }
   name ColorMatrix5
   xpos 0
   ypos 54
   disable {{parent.xzrot==0}}
  }
  Expression {
   temp_name0 nx
   temp_expr0 parent.Plane.pick.r
   temp_name1 ny
   temp_expr1 parent.Plane.pick.g
   temp_name2 nz
   temp_expr2 parent.Plane.pick.b
   channel0 {rgba.red -rgba.green -rgba.blue -rgba.alpha}
   expr0 r*nx
   channel1 {-rgba.red rgba.green -rgba.blue none}
   expr1 g*ny
   channel2 {-rgba.red -rgba.green rgba.blue none}
   expr2 b*nz
   channel3 {none none none -rgba.alpha}
   name Expression1
   xpos 0
   ypos 121
   cached true
  }
  Expression {
   expr3 clamp(r+g+b)
   name Expression3
   xpos 0
   ypos 187
  }
  Invert {
   channels alpha
   name Invert1
   xpos 0
   ypos 249
   disable {{!parent.inv}}
  }
  Expression {
   expr3 pow(a,max(1,parent.exp))
   name Expression4
   xpos 0
   ypos 317
  }
  Grade {
   channels alpha
   blackpoint {{-parent.mblack}}
   white {{parent.mgain}}
   gamma {{max(0.001,parent.mgamma)}}
   white_clamp true
   name Grade1
   xpos 0
   ypos 369
  }
  ChannelMerge {
   inputs 2
   operation multiply
   name ChannelMerge1
   xpos 0
   ypos 444
   disable {{!parent.amask}}
  }
push 0
  Merge2 {
   inputs 2+1
   operation copy
   also_merge all
   name Merge1
   label "\[ expr \{ \[value mix] == 1 ? \" \" : \[concat Mix: \[value mix]] \}]"
   xpos 0
   ypos 544
  }
  Output {
   name Output1
   xpos 0
   ypos 623
  }
 end_group
 Dot {
  name Dot46
  xpos 2008
  ypos 917
 }
 Grade {
  inputs 1+1
  channels rgba
  white 0
  name Grade8
  xpos 1974
  ypos 961
 }
 Dot {
  name Dot47
  xpos 2008
  ypos 1028
 }
 Dot {
  name Dot48
  xpos 2401
  ypos 1028
 }
 Dot {
  name Dot49
  xpos 2401
  ypos 1131
 }
push $N12b75200
push 0
 Camera3 {
  inputs 2
  translate {161.1999969 132.3999939 -2.961195904e-14}
  focal 100
  name Cam270
  xpos 2208
  ypos 351
 }
set N16480500 [stack 0]
 Dot {
  name Dot20
  xpos 2329
  ypos 375
 }
 Dot {
  name Dot21
  xpos 2329
  ypos 692
 }
push $N16480500
push $N1276f180
add_layer {projection_Cam270 projection_Cam270.red projection_Cam270.green projection_Cam270.blue}
 Shuffle2 {
  fromInput1 {
   {0}
   B
  }
  in1 projection_Cam270
  fromInput2 {
   {0}
   B
  }
  mappings "4 projection_Cam270.red 0 0 rgba.red 0 0 projection_Cam270.green 0 1 rgba.green 0 1 projection_Cam270.blue 0 2 rgba.blue 0 2 white -1 -1 rgba.alpha 0 3"
  name Shuffle7
  xpos 2035
  ypos 513
 }
 Project3D2 {
  inputs 2
  project_on front
  occlusion_mode world
  name Project3D7
  xpos 2198
  ypos 515
 }
clone $C1772aa00 {
  xpos 2198
  ypos 539
  selected false
 }
clone $C1772af00 {
  xpos 2198
  ypos 604
  selected false
 }
push 0
clone $C1772b400 {
  inputs 3
  xpos 2197
  ypos 689
  selected false
 }
 Dot {
  name Dot22
  xpos 2232
  ypos 1050
 }
set N164ba400 [stack 0]
 Group {
  name NormalsRotate7
  onCreate "\nn=nuke.thisNode()\nn\['mblack'].setFlag(0x0000000000000004)\nn\['mgain'].setFlag(0x0000000000000004)\nn\['mgamma'].setFlag(0x0000000000000004)\n"
  tile_color 0xff00ff
  xpos 2288
  ypos 1047
  addUserKnob {20 User}
  addUserKnob {41 in l "Normals in" t "Select the layer containing the \nnormals" T Shuffle1.in}
  addUserKnob {41 pick l "Pick Plane" T Plane.pick}
  addUserKnob {22 planereset l Reset -STARTLINE T "nuke.thisNode().knob(\"pick\").setValue(0,0)\nnuke.thisNode().knob(\"pick\").setValue(0,1)\nnuke.thisNode().knob(\"pick\").setValue(1,2)"}
  addUserKnob {26 ""}
  addUserKnob {26 divider_2 l "" +STARTLINE T " "}
  addUserKnob {26 manual l "<b>Manual Rotation</b>" -STARTLINE T "  "}
  addUserKnob {22 rotreset l Reset -STARTLINE T "nuke.thisNode().knob(\"yoffset\").setValue(0)\nnuke.thisNode().knob(\"xzrot\").setValue(0)"}
  addUserKnob {7 yoffset l Horizontal t "Rotate around the world Y axis" R -180 180}
  yoffset {{"degrees(atan2(Cam270.world_matrix.2, Cam270.world_matrix.10))+15"}}
  addUserKnob {7 xzrot l Vertical t "Rotates around the rotated X axis" R -180 180}
  addUserKnob {26 ""}
  addUserKnob {26 matte l "@b;Matte Output" T "      "}
  addUserKnob {6 inv l "Invert    " t "This happens before the matte \ntweaks" -STARTLINE}
  addUserKnob {6 amask l "Mask by Alpha    " -STARTLINE}
  addUserKnob {6 unpre l Unpremult -STARTLINE}
  addUserKnob {7 exp l Exponent t "Exponential falloff" R 1 10}
  exp 1.25
  addUserKnob {22 expreset l Reset -STARTLINE T "nuke.thisNode().knob(\"exp\").setValue(2)"}
  addUserKnob {7 mblack l Black R -1 1}
  addUserKnob {22 mblackreset l Reset -STARTLINE T "nuke.thisNode().knob(\"mblack\").setValue(0)"}
  addUserKnob {7 mgain l White R 0 4}
  mgain 6
  addUserKnob {22 mgainreset l Reset -STARTLINE T "nuke.thisNode().knob(\"mgain\").setValue(1)"}
  addUserKnob {7 mgamma l Gamma R 0 4}
  mgamma 1
  addUserKnob {22 mgammareset l Reset -STARTLINE T "nuke.thisNode().knob(\"mgamma\").setValue(1)"}
  addUserKnob {26 ""}
  addUserKnob {26 "" l mask T ""}
  addUserKnob {41 maskChannelInput l "" -STARTLINE T Merge1.maskChannelInput}
  addUserKnob {41 inject -STARTLINE T Merge1.inject}
  addUserKnob {41 invert_mask l invert -STARTLINE T Merge1.invert_mask}
  addUserKnob {41 fringe -STARTLINE T Merge1.fringe}
  addUserKnob {41 mix T Merge1.mix}
  addUserKnob {20 info l Info}
  addUserKnob {26 infotext l "" +STARTLINE T "W_SuperNormal generates a surface angle based matte using normals.\n\n1. Select the layer containing normals in the dropdown menu.\n2. Enable color picker and pick the point where you want the matte to be white.\n  (I look at the alpha output, hold ctrl+alt and \"glide\" over the surfaces.)\n3. You can also manually rotate the matte. When you colorpick a new point,\n  it is recommended that you reset the manual rotation values to 0.\n"}
  addUserKnob {20 v2_1_group l "v2.1 - Feb 2019" n 1}
  v2_1_group 0
  addUserKnob {26 v2_1_text l "" +STARTLINE T "  -Manual rotation working as originally envisioned: It is more intuitive \n   and faster to reach any desired angle with horizontal(Y) and vertical\n   rotation than with separate XYZ rotations.\n  -General cleanup & refinements.\n"}
  addUserKnob {20 endGroup n -1}
  addUserKnob {20 v2group l "v2.0 - 2018" n 1}
  v2group 0
  addUserKnob {26 v2text l "" +STARTLINE T "  -Adopted a different method for rotating normals shown to me by Daniel Pelc\n  -Simpler math for converting normals into a matte with the help of Erwan Leroy\n"}
  addUserKnob {20 endGroup_1 l endGroup n -1}
  addUserKnob {26 v1_1_text l "" +STARTLINE T "    v1.1 - 2016"}
  addUserKnob {26 ""}
  addUserKnob {26 spacer_1 l "" +STARTLINE T "     "}
  addUserKnob {26 copyright l "&#169;  Wes Heo" -STARTLINE T " "}
 }
  Axis2 {
   inputs 0
   rot_order YXZ
   rotate {0 {-parent.yoffset} 0}
   name Axis10
   label H
   xpos -173
   ypos -163
  }
  Axis2 {
   inputs 0
   rot_order YXZ
   rotate {{parent.xzrot} {-degrees(parent.Plane.picked.g)} 0}
   name Axis2
   label V
   xpos -171
   ypos -62
  }
  Axis2 {
   inputs 0
   rot_order YXZ
   rotate {0 {-parent.Axis2.rotate.y} 0}
   name Axis5
   label V
   xpos -170
   ypos 34
  }
  Input {
   inputs 0
   name Inputmask
   xpos 132
   ypos 544
   number 1
  }
  Input {
   inputs 0
   name N
   xpos 0
   ypos -425
  }
  Shuffle {
   in N
   alpha red2
   out rgb
   name Shuffle1
   xpos 0
   ypos -347
  }
set N16483700 [stack 0]
  Dot {
   name Dot1
   xpos 315
   ypos 289
  }
push $N16483700
  Unpremult {
   name Unpremult1
   xpos 0
   ypos -286
   disable {{!parent.unpre}}
  }
  NoOp {
   name Plane
   xpos 0
   ypos -218
   addUserKnob {20 User}
   addUserKnob {18 pick l "User Picked Plane" R -1 1}
   pick {0 0 1}
   addUserKnob {6 pick_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {20 calc l "Internal Conversions"}
   addUserKnob {18 picked}
   picked {0 {"(atan2(pick.r, pick.b))"} 0}
   addUserKnob {6 picked_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
  }
  ColorMatrix {
   matrix {
    
        {{parent.Axis10.world_matrix.0} {parent.Axis10.world_matrix.1} {parent.Axis10.world_matrix.2}}
        {{parent.Axis10.world_matrix.4} {parent.Axis10.world_matrix.5} {parent.Axis10.world_matrix.6}}
        {{parent.Axis10.world_matrix.8} {parent.Axis10.world_matrix.9} {parent.Axis10.world_matrix.10}}
   }
   name ColorMatrix2
   xpos 0
   ypos -148
   disable {{parent.yoffset==0}}
  }
  ColorMatrix {
   matrix {
    
        {{parent.Axis2.world_matrix.0} {parent.Axis2.world_matrix.1} {parent.Axis2.world_matrix.2}}
        {{parent.Axis2.world_matrix.4} {parent.Axis2.world_matrix.5} {parent.Axis2.world_matrix.6}}
        {{parent.Axis2.world_matrix.8} {parent.Axis2.world_matrix.9} {parent.Axis2.world_matrix.10}}
   }
   name ColorMatrix3
   xpos 0
   ypos -42
   disable {{parent.xzrot==0}}
  }
  ColorMatrix {
   matrix {
    
        {{parent.Axis5.world_matrix.0} {parent.Axis5.world_matrix.1} {parent.Axis5.world_matrix.2}}
        {{parent.Axis5.world_matrix.4} {parent.Axis5.world_matrix.5} {parent.Axis5.world_matrix.6}}
        {{parent.Axis5.world_matrix.8} {parent.Axis5.world_matrix.9} {parent.Axis5.world_matrix.10}}
   }
   name ColorMatrix5
   xpos 0
   ypos 54
   disable {{parent.xzrot==0}}
  }
  Expression {
   temp_name0 nx
   temp_expr0 parent.Plane.pick.r
   temp_name1 ny
   temp_expr1 parent.Plane.pick.g
   temp_name2 nz
   temp_expr2 parent.Plane.pick.b
   channel0 {rgba.red -rgba.green -rgba.blue -rgba.alpha}
   expr0 r*nx
   channel1 {-rgba.red rgba.green -rgba.blue none}
   expr1 g*ny
   channel2 {-rgba.red -rgba.green rgba.blue none}
   expr2 b*nz
   channel3 {none none none -rgba.alpha}
   name Expression1
   xpos 0
   ypos 121
   cached true
  }
  Expression {
   expr3 clamp(r+g+b)
   name Expression3
   xpos 0
   ypos 187
  }
  Invert {
   channels alpha
   name Invert1
   xpos 0
   ypos 249
   disable {{!parent.inv}}
  }
  Expression {
   expr3 pow(a,max(1,parent.exp))
   name Expression4
   xpos 0
   ypos 317
  }
  Grade {
   channels alpha
   blackpoint {{-parent.mblack}}
   white {{parent.mgain}}
   gamma {{max(0.001,parent.mgamma)}}
   white_clamp true
   name Grade1
   xpos 0
   ypos 369
  }
  ChannelMerge {
   inputs 2
   operation multiply
   name ChannelMerge1
   xpos 0
   ypos 444
   disable {{!parent.amask}}
  }
push 0
  Merge2 {
   inputs 2+1
   operation copy
   also_merge all
   name Merge1
   label "\[ expr \{ \[value mix] == 1 ? \" \" : \[concat Mix: \[value mix]] \}]"
   xpos 0
   ypos 544
  }
  Output {
   name Output1
   xpos 0
   ypos 623
  }
 end_group
clone $C162fde00 {
  xpos 2288
  ypos 1078
  selected false
 }
 Grade {
  inputs 1+1
  channels rgba
  white 0
  name Grade9
  xpos 2288
  ypos 1128
 }
push $N164ba400
push $N162ff700
push $N12b5bc00
 Dot {
  name Dot39
  xpos -526
  ypos 812
 }
set N164bb400 [stack 0]
 Invert {
  name Invert3
  xpos -485
  ypos 803
 }
clone $C16364800 {
  inputs 1+1
  xpos -418
  ypos 809
  selected false
 }
 Erode {
  channels all
  size -23
  blur 0.365
  name Erode3
  xpos -341
  ypos 803
 }
push $N12b5bc00
 Group {
  name NormalsRotate9
  onCreate "\nn=nuke.thisNode()\nn\['mblack'].setFlag(0x0000000000000004)\nn\['mgain'].setFlag(0x0000000000000004)\nn\['mgamma'].setFlag(0x0000000000000004)\n"
  tile_color 0xff00ff
  xpos -368
  ypos 762
  addUserKnob {20 User}
  addUserKnob {41 in l "Normals in" t "Select the layer containing the \nnormals" T Shuffle1.in}
  addUserKnob {41 pick l "Pick Plane" T Plane.pick}
  addUserKnob {22 planereset l Reset -STARTLINE T "nuke.thisNode().knob(\"pick\").setValue(0,0)\nnuke.thisNode().knob(\"pick\").setValue(0,1)\nnuke.thisNode().knob(\"pick\").setValue(1,2)"}
  addUserKnob {26 ""}
  addUserKnob {26 divider_2 l "" +STARTLINE T " "}
  addUserKnob {26 manual l "<b>Manual Rotation</b>" -STARTLINE T "  "}
  addUserKnob {22 rotreset l Reset -STARTLINE T "nuke.thisNode().knob(\"yoffset\").setValue(0)\nnuke.thisNode().knob(\"xzrot\").setValue(0)"}
  addUserKnob {7 yoffset l Horizontal t "Rotate around the world Y axis" R -180 180}
  yoffset {{"degrees(atan2(CamInit.world_matrix.2, CamInit.world_matrix.10))-10"}}
  addUserKnob {7 xzrot l Vertical t "Rotates around the rotated X axis" R -180 180}
  addUserKnob {26 ""}
  addUserKnob {26 matte l "@b;Matte Output" T "      "}
  addUserKnob {6 inv l "Invert    " t "This happens before the matte \ntweaks" -STARTLINE}
  addUserKnob {6 amask l "Mask by Alpha    " -STARTLINE}
  amask true
  addUserKnob {6 unpre l Unpremult -STARTLINE}
  addUserKnob {7 exp l Exponent t "Exponential falloff" R 1 10}
  exp 2
  addUserKnob {22 expreset l Reset -STARTLINE T "nuke.thisNode().knob(\"exp\").setValue(2)"}
  addUserKnob {7 mblack l Black R -1 1}
  addUserKnob {22 mblackreset l Reset -STARTLINE T "nuke.thisNode().knob(\"mblack\").setValue(0)"}
  addUserKnob {7 mgain l White R 0 4}
  mgain 2
  addUserKnob {22 mgainreset l Reset -STARTLINE T "nuke.thisNode().knob(\"mgain\").setValue(1)"}
  addUserKnob {7 mgamma l Gamma R 0 4}
  mgamma 1
  addUserKnob {22 mgammareset l Reset -STARTLINE T "nuke.thisNode().knob(\"mgamma\").setValue(1)"}
  addUserKnob {26 ""}
  addUserKnob {26 "" l mask T ""}
  addUserKnob {41 maskChannelInput l "" -STARTLINE T Merge1.maskChannelInput}
  addUserKnob {41 inject -STARTLINE T Merge1.inject}
  addUserKnob {41 invert_mask l invert -STARTLINE T Merge1.invert_mask}
  addUserKnob {41 fringe -STARTLINE T Merge1.fringe}
  addUserKnob {41 mix T Merge1.mix}
  addUserKnob {20 info l Info}
  addUserKnob {26 infotext l "" +STARTLINE T "W_SuperNormal generates a surface angle based matte using normals.\n\n1. Select the layer containing normals in the dropdown menu.\n2. Enable color picker and pick the point where you want the matte to be white.\n  (I look at the alpha output, hold ctrl+alt and \"glide\" over the surfaces.)\n3. You can also manually rotate the matte. When you colorpick a new point,\n  it is recommended that you reset the manual rotation values to 0.\n"}
  addUserKnob {20 v2_1_group l "v2.1 - Feb 2019" n 1}
  v2_1_group 0
  addUserKnob {26 v2_1_text l "" +STARTLINE T "  -Manual rotation working as originally envisioned: It is more intuitive \n   and faster to reach any desired angle with horizontal(Y) and vertical\n   rotation than with separate XYZ rotations.\n  -General cleanup & refinements.\n"}
  addUserKnob {20 endGroup n -1}
  addUserKnob {20 v2group l "v2.0 - 2018" n 1}
  v2group 0
  addUserKnob {26 v2text l "" +STARTLINE T "  -Adopted a different method for rotating normals shown to me by Daniel Pelc\n  -Simpler math for converting normals into a matte with the help of Erwan Leroy\n"}
  addUserKnob {20 endGroup_1 l endGroup n -1}
  addUserKnob {26 v1_1_text l "" +STARTLINE T "    v1.1 - 2016"}
  addUserKnob {26 ""}
  addUserKnob {26 spacer_1 l "" +STARTLINE T "     "}
  addUserKnob {26 copyright l "&#169;  Wes Heo" -STARTLINE T " "}
 }
  Axis2 {
   inputs 0
   rot_order YXZ
   rotate {0 {-parent.yoffset} 0}
   name Axis10
   label H
   xpos -173
   ypos -163
  }
  Axis2 {
   inputs 0
   rot_order YXZ
   rotate {{parent.xzrot} {-degrees(parent.Plane.picked.g)} 0}
   name Axis2
   label V
   xpos -171
   ypos -62
  }
  Axis2 {
   inputs 0
   rot_order YXZ
   rotate {0 {-parent.Axis2.rotate.y} 0}
   name Axis5
   label V
   xpos -170
   ypos 34
  }
  Input {
   inputs 0
   name Inputmask
   xpos 132
   ypos 544
   number 1
  }
  Input {
   inputs 0
   name N
   xpos 0
   ypos -425
  }
  Shuffle {
   in N
   alpha red2
   out rgb
   name Shuffle1
   xpos 0
   ypos -347
  }
set N1b979e00 [stack 0]
  Dot {
   name Dot1
   xpos 315
   ypos 289
  }
push $N1b979e00
  Unpremult {
   name Unpremult1
   xpos 0
   ypos -286
   disable {{!parent.unpre}}
  }
  NoOp {
   name Plane
   xpos 0
   ypos -218
   addUserKnob {20 User}
   addUserKnob {18 pick l "User Picked Plane" R -1 1}
   pick {0 0 1}
   addUserKnob {6 pick_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {20 calc l "Internal Conversions"}
   addUserKnob {18 picked}
   picked {0 {"(atan2(pick.r, pick.b))"} 0}
   addUserKnob {6 picked_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
  }
  ColorMatrix {
   matrix {
    
        {{parent.Axis10.world_matrix.0} {parent.Axis10.world_matrix.1} {parent.Axis10.world_matrix.2}}
        {{parent.Axis10.world_matrix.4} {parent.Axis10.world_matrix.5} {parent.Axis10.world_matrix.6}}
        {{parent.Axis10.world_matrix.8} {parent.Axis10.world_matrix.9} {parent.Axis10.world_matrix.10}}
   }
   name ColorMatrix2
   xpos 0
   ypos -148
   disable {{parent.yoffset==0}}
  }
  ColorMatrix {
   matrix {
    
        {{parent.Axis2.world_matrix.0} {parent.Axis2.world_matrix.1} {parent.Axis2.world_matrix.2}}
        {{parent.Axis2.world_matrix.4} {parent.Axis2.world_matrix.5} {parent.Axis2.world_matrix.6}}
        {{parent.Axis2.world_matrix.8} {parent.Axis2.world_matrix.9} {parent.Axis2.world_matrix.10}}
   }
   name ColorMatrix3
   xpos 0
   ypos -42
   disable {{parent.xzrot==0}}
  }
  ColorMatrix {
   matrix {
    
        {{parent.Axis5.world_matrix.0} {parent.Axis5.world_matrix.1} {parent.Axis5.world_matrix.2}}
        {{parent.Axis5.world_matrix.4} {parent.Axis5.world_matrix.5} {parent.Axis5.world_matrix.6}}
        {{parent.Axis5.world_matrix.8} {parent.Axis5.world_matrix.9} {parent.Axis5.world_matrix.10}}
   }
   name ColorMatrix5
   xpos 0
   ypos 54
   disable {{parent.xzrot==0}}
  }
  Expression {
   temp_name0 nx
   temp_expr0 parent.Plane.pick.r
   temp_name1 ny
   temp_expr1 parent.Plane.pick.g
   temp_name2 nz
   temp_expr2 parent.Plane.pick.b
   channel0 {rgba.red -rgba.green -rgba.blue -rgba.alpha}
   expr0 r*nx
   channel1 {-rgba.red rgba.green -rgba.blue none}
   expr1 g*ny
   channel2 {-rgba.red -rgba.green rgba.blue none}
   expr2 b*nz
   channel3 {none none none -rgba.alpha}
   name Expression1
   xpos 0
   ypos 121
   cached true
  }
  Expression {
   expr3 clamp(r+g+b)
   name Expression3
   xpos 0
   ypos 187
  }
  Invert {
   channels alpha
   name Invert1
   xpos 0
   ypos 249
   disable {{!parent.inv}}
  }
  Expression {
   expr3 pow(a,max(1,parent.exp))
   name Expression4
   xpos 0
   ypos 317
  }
  Grade {
   channels alpha
   blackpoint {{-parent.mblack}}
   white {{parent.mgain}}
   gamma {{max(0.001,parent.mgamma)}}
   white_clamp true
   name Grade1
   xpos 0
   ypos 369
  }
  ChannelMerge {
   inputs 2
   operation multiply
   name ChannelMerge1
   xpos 0
   ypos 444
   disable {{!parent.amask}}
  }
push 0
  Merge2 {
   inputs 2+1
   operation copy
   also_merge all
   name Merge1
   label "\[ expr \{ \[value mix] == 1 ? \" \" : \[concat Mix: \[value mix]] \}]"
   xpos 0
   ypos 544
  }
  Output {
   name Output1
   xpos 0
   ypos 623
  }
 end_group
 Dot {
  name Dot40
  xpos -207
  ypos 765
 }
 Grade {
  inputs 1+1
  channels rgba
  white 0
  name Grade6
  xpos -241
  ypos 809
 }
 Dot {
  name Dot41
  xpos -207
  ypos 876
 }
 Dot {
  name Dot42
  xpos 1887
  ypos 876
 }
 Dot {
  name Dot43
  xpos 1887
  ypos 1137
 }
push $N1631d800
 Dot {
  name Dot19
  xpos 1689
  ypos 1049
 }
set N1ba33400 [stack 0]
 Group {
  name NormalsRotate6
  onCreate "\nn=nuke.thisNode()\nn\['mblack'].setFlag(0x0000000000000004)\nn\['mgain'].setFlag(0x0000000000000004)\nn\['mgamma'].setFlag(0x0000000000000004)\n"
  tile_color 0xff00ff
  xpos 1749
  ypos 1046
  addUserKnob {20 User}
  addUserKnob {41 in l "Normals in" t "Select the layer containing the \nnormals" T Shuffle1.in}
  addUserKnob {41 pick l "Pick Plane" T Plane.pick}
  addUserKnob {22 planereset l Reset -STARTLINE T "nuke.thisNode().knob(\"pick\").setValue(0,0)\nnuke.thisNode().knob(\"pick\").setValue(0,1)\nnuke.thisNode().knob(\"pick\").setValue(1,2)"}
  addUserKnob {26 ""}
  addUserKnob {26 divider_2 l "" +STARTLINE T " "}
  addUserKnob {26 manual l "<b>Manual Rotation</b>" -STARTLINE T "  "}
  addUserKnob {22 rotreset l Reset -STARTLINE T "nuke.thisNode().knob(\"yoffset\").setValue(0)\nnuke.thisNode().knob(\"xzrot\").setValue(0)"}
  addUserKnob {7 yoffset l Horizontal t "Rotate around the world Y axis" R -180 180}
  yoffset {{"degrees(atan2(Cam315.world_matrix.2, Cam315.world_matrix.10))+10" x1001 55}}
  addUserKnob {7 xzrot l Vertical t "Rotates around the rotated X axis" R -180 180}
  addUserKnob {26 ""}
  addUserKnob {26 matte l "@b;Matte Output" T "      "}
  addUserKnob {6 inv l "Invert    " t "This happens before the matte \ntweaks" -STARTLINE}
  addUserKnob {6 amask l "Mask by Alpha    " -STARTLINE}
  addUserKnob {6 unpre l Unpremult -STARTLINE}
  addUserKnob {7 exp l Exponent t "Exponential falloff" R 1 10}
  exp 1.25
  addUserKnob {22 expreset l Reset -STARTLINE T "nuke.thisNode().knob(\"exp\").setValue(2)"}
  addUserKnob {7 mblack l Black R -1 1}
  addUserKnob {22 mblackreset l Reset -STARTLINE T "nuke.thisNode().knob(\"mblack\").setValue(0)"}
  addUserKnob {7 mgain l White R 0 4}
  mgain 6
  addUserKnob {22 mgainreset l Reset -STARTLINE T "nuke.thisNode().knob(\"mgain\").setValue(1)"}
  addUserKnob {7 mgamma l Gamma R 0 4}
  mgamma 1
  addUserKnob {22 mgammareset l Reset -STARTLINE T "nuke.thisNode().knob(\"mgamma\").setValue(1)"}
  addUserKnob {26 ""}
  addUserKnob {26 "" l mask T ""}
  addUserKnob {41 maskChannelInput l "" -STARTLINE T Merge1.maskChannelInput}
  addUserKnob {41 inject -STARTLINE T Merge1.inject}
  addUserKnob {41 invert_mask l invert -STARTLINE T Merge1.invert_mask}
  addUserKnob {41 fringe -STARTLINE T Merge1.fringe}
  addUserKnob {41 mix T Merge1.mix}
  addUserKnob {20 info l Info}
  addUserKnob {26 infotext l "" +STARTLINE T "W_SuperNormal generates a surface angle based matte using normals.\n\n1. Select the layer containing normals in the dropdown menu.\n2. Enable color picker and pick the point where you want the matte to be white.\n  (I look at the alpha output, hold ctrl+alt and \"glide\" over the surfaces.)\n3. You can also manually rotate the matte. When you colorpick a new point,\n  it is recommended that you reset the manual rotation values to 0.\n"}
  addUserKnob {20 v2_1_group l "v2.1 - Feb 2019" n 1}
  v2_1_group 0
  addUserKnob {26 v2_1_text l "" +STARTLINE T "  -Manual rotation working as originally envisioned: It is more intuitive \n   and faster to reach any desired angle with horizontal(Y) and vertical\n   rotation than with separate XYZ rotations.\n  -General cleanup & refinements.\n"}
  addUserKnob {20 endGroup n -1}
  addUserKnob {20 v2group l "v2.0 - 2018" n 1}
  v2group 0
  addUserKnob {26 v2text l "" +STARTLINE T "  -Adopted a different method for rotating normals shown to me by Daniel Pelc\n  -Simpler math for converting normals into a matte with the help of Erwan Leroy\n"}
  addUserKnob {20 endGroup_1 l endGroup n -1}
  addUserKnob {26 v1_1_text l "" +STARTLINE T "    v1.1 - 2016"}
  addUserKnob {26 ""}
  addUserKnob {26 spacer_1 l "" +STARTLINE T "     "}
  addUserKnob {26 copyright l "&#169;  Wes Heo" -STARTLINE T " "}
 }
  Axis2 {
   inputs 0
   rot_order YXZ
   rotate {0 {-parent.yoffset} 0}
   name Axis10
   label H
   xpos -173
   ypos -163
  }
  Axis2 {
   inputs 0
   rot_order YXZ
   rotate {{parent.xzrot} {-degrees(parent.Plane.picked.g)} 0}
   name Axis2
   label V
   xpos -171
   ypos -62
  }
  Axis2 {
   inputs 0
   rot_order YXZ
   rotate {0 {-parent.Axis2.rotate.y} 0}
   name Axis5
   label V
   xpos -170
   ypos 34
  }
  Input {
   inputs 0
   name Inputmask
   xpos 132
   ypos 544
   number 1
  }
  Input {
   inputs 0
   name N
   xpos 0
   ypos -425
  }
  Shuffle {
   in N
   alpha red2
   out rgb
   name Shuffle1
   xpos 0
   ypos -347
  }
set N1ba6ca00 [stack 0]
  Dot {
   name Dot1
   xpos 315
   ypos 289
  }
push $N1ba6ca00
  Unpremult {
   name Unpremult1
   xpos 0
   ypos -286
   disable {{!parent.unpre}}
  }
  NoOp {
   name Plane
   xpos 0
   ypos -218
   addUserKnob {20 User}
   addUserKnob {18 pick l "User Picked Plane" R -1 1}
   pick {0 0 1}
   addUserKnob {6 pick_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {20 calc l "Internal Conversions"}
   addUserKnob {18 picked}
   picked {0 {"(atan2(pick.r, pick.b))"} 0}
   addUserKnob {6 picked_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
  }
  ColorMatrix {
   matrix {
    
        {{parent.Axis10.world_matrix.0} {parent.Axis10.world_matrix.1} {parent.Axis10.world_matrix.2}}
        {{parent.Axis10.world_matrix.4} {parent.Axis10.world_matrix.5} {parent.Axis10.world_matrix.6}}
        {{parent.Axis10.world_matrix.8} {parent.Axis10.world_matrix.9} {parent.Axis10.world_matrix.10}}
   }
   name ColorMatrix2
   xpos 0
   ypos -148
   disable {{parent.yoffset==0}}
  }
  ColorMatrix {
   matrix {
    
        {{parent.Axis2.world_matrix.0} {parent.Axis2.world_matrix.1} {parent.Axis2.world_matrix.2}}
        {{parent.Axis2.world_matrix.4} {parent.Axis2.world_matrix.5} {parent.Axis2.world_matrix.6}}
        {{parent.Axis2.world_matrix.8} {parent.Axis2.world_matrix.9} {parent.Axis2.world_matrix.10}}
   }
   name ColorMatrix3
   xpos 0
   ypos -42
   disable {{parent.xzrot==0}}
  }
  ColorMatrix {
   matrix {
    
        {{parent.Axis5.world_matrix.0} {parent.Axis5.world_matrix.1} {parent.Axis5.world_matrix.2}}
        {{parent.Axis5.world_matrix.4} {parent.Axis5.world_matrix.5} {parent.Axis5.world_matrix.6}}
        {{parent.Axis5.world_matrix.8} {parent.Axis5.world_matrix.9} {parent.Axis5.world_matrix.10}}
   }
   name ColorMatrix5
   xpos 0
   ypos 54
   disable {{parent.xzrot==0}}
  }
  Expression {
   temp_name0 nx
   temp_expr0 parent.Plane.pick.r
   temp_name1 ny
   temp_expr1 parent.Plane.pick.g
   temp_name2 nz
   temp_expr2 parent.Plane.pick.b
   channel0 {rgba.red -rgba.green -rgba.blue -rgba.alpha}
   expr0 r*nx
   channel1 {-rgba.red rgba.green -rgba.blue none}
   expr1 g*ny
   channel2 {-rgba.red -rgba.green rgba.blue none}
   expr2 b*nz
   channel3 {none none none -rgba.alpha}
   name Expression1
   xpos 0
   ypos 121
   cached true
  }
  Expression {
   expr3 clamp(r+g+b)
   name Expression3
   xpos 0
   ypos 187
  }
  Invert {
   channels alpha
   name Invert1
   xpos 0
   ypos 249
   disable {{!parent.inv}}
  }
  Expression {
   expr3 pow(a,max(1,parent.exp))
   name Expression4
   xpos 0
   ypos 317
  }
  Grade {
   channels alpha
   blackpoint {{-parent.mblack}}
   white {{parent.mgain}}
   gamma {{max(0.001,parent.mgamma)}}
   white_clamp true
   name Grade1
   xpos 0
   ypos 369
  }
  ChannelMerge {
   inputs 2
   operation multiply
   name ChannelMerge1
   xpos 0
   ypos 444
   disable {{!parent.amask}}
  }
push 0
  Merge2 {
   inputs 2+1
   operation copy
   also_merge all
   name Merge1
   label "\[ expr \{ \[value mix] == 1 ? \" \" : \[concat Mix: \[value mix]] \}]"
   xpos 0
   ypos 544
  }
  Output {
   name Output1
   xpos 0
   ypos 623
  }
 end_group
clone $C162fde00 {
  xpos 1749
  ypos 1084
  selected false
 }
 Grade {
  inputs 1+1
  channels rgba
  white 0
  name Grade7
  xpos 1749
  ypos 1134
 }
push $N1ba33400
push $N12b75200
push 0
 Camera3 {
  inputs 2
  translate {-113.985611 132.3999939 -113.985611}
  focal 100
  name Cam135
  xpos 1064
  ypos 338
 }
set N1bb0a800 [stack 0]
 Dot {
  name Dot11
  xpos 1185
  ypos 362
 }
 Dot {
  name Dot12
  xpos 1185
  ypos 679
 }
push $N1bb0a800
push $N1276f180
add_layer {projection_Cam135 projection_Cam135.red projection_Cam135.green projection_Cam135.blue}
 Shuffle2 {
  fromInput1 {
   {0}
   B
  }
  in1 projection_Cam135
  fromInput2 {
   {0}
   B
  }
  mappings "4 projection_Cam135.red 0 0 rgba.red 0 0 projection_Cam135.green 0 1 rgba.green 0 1 projection_Cam135.blue 0 2 rgba.blue 0 2 white -1 -1 rgba.alpha 0 3"
  name Shuffle6
  xpos 937
  ypos 502
 }
 Project3D2 {
  inputs 2
  project_on front
  occlusion_mode world
  name Project3D4
  xpos 1054
  ypos 502
 }
clone $C1772aa00 {
  xpos 1054
  ypos 538
  selected false
 }
clone $C1772af00 {
  xpos 1054
  ypos 599
  selected false
 }
push 0
clone $C1772b400 {
  inputs 3
  xpos 1053
  ypos 676
  selected false
 }
 Dot {
  name Dot13
  xpos 1088
  ypos 1049
 }
set N1bafb000 [stack 0]
 Group {
  name NormalsRotate3
  onCreate "\nn=nuke.thisNode()\nn\['mblack'].setFlag(0x0000000000000004)\nn\['mgain'].setFlag(0x0000000000000004)\nn\['mgamma'].setFlag(0x0000000000000004)\n"
  tile_color 0xff00ff
  xpos 1148
  ypos 1046
  addUserKnob {20 User}
  addUserKnob {41 in l "Normals in" t "Select the layer containing the \nnormals" T Shuffle1.in}
  addUserKnob {41 pick l "Pick Plane" T Plane.pick}
  addUserKnob {22 planereset l Reset -STARTLINE T "nuke.thisNode().knob(\"pick\").setValue(0,0)\nnuke.thisNode().knob(\"pick\").setValue(0,1)\nnuke.thisNode().knob(\"pick\").setValue(1,2)"}
  addUserKnob {26 ""}
  addUserKnob {26 divider_2 l "" +STARTLINE T " "}
  addUserKnob {26 manual l "<b>Manual Rotation</b>" -STARTLINE T "  "}
  addUserKnob {22 rotreset l Reset -STARTLINE T "nuke.thisNode().knob(\"yoffset\").setValue(0)\nnuke.thisNode().knob(\"xzrot\").setValue(0)"}
  addUserKnob {7 yoffset l Horizontal t "Rotate around the world Y axis" R -180 180}
  yoffset {{"degrees(atan2(Cam135.world_matrix.2, Cam135.world_matrix.10))-15"}}
  addUserKnob {7 xzrot l Vertical t "Rotates around the rotated X axis" R -180 180}
  addUserKnob {26 ""}
  addUserKnob {26 matte l "@b;Matte Output" T "      "}
  addUserKnob {6 inv l "Invert    " t "This happens before the matte \ntweaks" -STARTLINE}
  addUserKnob {6 amask l "Mask by Alpha    " -STARTLINE}
  addUserKnob {6 unpre l Unpremult -STARTLINE}
  addUserKnob {7 exp l Exponent t "Exponential falloff" R 1 10}
  exp 2.2
  addUserKnob {22 expreset l Reset -STARTLINE T "nuke.thisNode().knob(\"exp\").setValue(2)"}
  addUserKnob {7 mblack l Black R -1 1}
  addUserKnob {22 mblackreset l Reset -STARTLINE T "nuke.thisNode().knob(\"mblack\").setValue(0)"}
  addUserKnob {7 mgain l White R 0 4}
  mgain 4
  addUserKnob {22 mgainreset l Reset -STARTLINE T "nuke.thisNode().knob(\"mgain\").setValue(1)"}
  addUserKnob {7 mgamma l Gamma R 0 4}
  mgamma 1
  addUserKnob {22 mgammareset l Reset -STARTLINE T "nuke.thisNode().knob(\"mgamma\").setValue(1)"}
  addUserKnob {26 ""}
  addUserKnob {26 "" l mask T ""}
  addUserKnob {41 maskChannelInput l "" -STARTLINE T Merge1.maskChannelInput}
  addUserKnob {41 inject -STARTLINE T Merge1.inject}
  addUserKnob {41 invert_mask l invert -STARTLINE T Merge1.invert_mask}
  addUserKnob {41 fringe -STARTLINE T Merge1.fringe}
  addUserKnob {41 mix T Merge1.mix}
  addUserKnob {20 info l Info}
  addUserKnob {26 infotext l "" +STARTLINE T "W_SuperNormal generates a surface angle based matte using normals.\n\n1. Select the layer containing normals in the dropdown menu.\n2. Enable color picker and pick the point where you want the matte to be white.\n  (I look at the alpha output, hold ctrl+alt and \"glide\" over the surfaces.)\n3. You can also manually rotate the matte. When you colorpick a new point,\n  it is recommended that you reset the manual rotation values to 0.\n"}
  addUserKnob {20 v2_1_group l "v2.1 - Feb 2019" n 1}
  v2_1_group 0
  addUserKnob {26 v2_1_text l "" +STARTLINE T "  -Manual rotation working as originally envisioned: It is more intuitive \n   and faster to reach any desired angle with horizontal(Y) and vertical\n   rotation than with separate XYZ rotations.\n  -General cleanup & refinements.\n"}
  addUserKnob {20 endGroup n -1}
  addUserKnob {20 v2group l "v2.0 - 2018" n 1}
  v2group 0
  addUserKnob {26 v2text l "" +STARTLINE T "  -Adopted a different method for rotating normals shown to me by Daniel Pelc\n  -Simpler math for converting normals into a matte with the help of Erwan Leroy\n"}
  addUserKnob {20 endGroup_1 l endGroup n -1}
  addUserKnob {26 v1_1_text l "" +STARTLINE T "    v1.1 - 2016"}
  addUserKnob {26 ""}
  addUserKnob {26 spacer_1 l "" +STARTLINE T "     "}
  addUserKnob {26 copyright l "&#169;  Wes Heo" -STARTLINE T " "}
 }
  Axis2 {
   inputs 0
   rot_order YXZ
   rotate {0 {-parent.yoffset} 0}
   name Axis10
   label H
   xpos -173
   ypos -163
  }
  Axis2 {
   inputs 0
   rot_order YXZ
   rotate {{parent.xzrot} {-degrees(parent.Plane.picked.g)} 0}
   name Axis2
   label V
   xpos -171
   ypos -62
  }
  Axis2 {
   inputs 0
   rot_order YXZ
   rotate {0 {-parent.Axis2.rotate.y} 0}
   name Axis5
   label V
   xpos -170
   ypos 34
  }
  Input {
   inputs 0
   name Inputmask
   xpos 132
   ypos 544
   number 1
  }
  Input {
   inputs 0
   name N
   xpos 0
   ypos -425
  }
  Shuffle {
   in N
   alpha red2
   out rgb
   name Shuffle1
   xpos 0
   ypos -347
  }
set N1bb3fe00 [stack 0]
  Dot {
   name Dot1
   xpos 315
   ypos 289
  }
push $N1bb3fe00
  Unpremult {
   name Unpremult1
   xpos 0
   ypos -286
   disable {{!parent.unpre}}
  }
  NoOp {
   name Plane
   xpos 0
   ypos -218
   addUserKnob {20 User}
   addUserKnob {18 pick l "User Picked Plane" R -1 1}
   pick {0 0 1}
   addUserKnob {6 pick_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {20 calc l "Internal Conversions"}
   addUserKnob {18 picked}
   picked {0 {"(atan2(pick.r, pick.b))"} 0}
   addUserKnob {6 picked_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
  }
  ColorMatrix {
   matrix {
    
        {{parent.Axis10.world_matrix.0} {parent.Axis10.world_matrix.1} {parent.Axis10.world_matrix.2}}
        {{parent.Axis10.world_matrix.4} {parent.Axis10.world_matrix.5} {parent.Axis10.world_matrix.6}}
        {{parent.Axis10.world_matrix.8} {parent.Axis10.world_matrix.9} {parent.Axis10.world_matrix.10}}
   }
   name ColorMatrix2
   xpos 0
   ypos -148
   disable {{parent.yoffset==0}}
  }
  ColorMatrix {
   matrix {
    
        {{parent.Axis2.world_matrix.0} {parent.Axis2.world_matrix.1} {parent.Axis2.world_matrix.2}}
        {{parent.Axis2.world_matrix.4} {parent.Axis2.world_matrix.5} {parent.Axis2.world_matrix.6}}
        {{parent.Axis2.world_matrix.8} {parent.Axis2.world_matrix.9} {parent.Axis2.world_matrix.10}}
   }
   name ColorMatrix3
   xpos 0
   ypos -42
   disable {{parent.xzrot==0}}
  }
  ColorMatrix {
   matrix {
    
        {{parent.Axis5.world_matrix.0} {parent.Axis5.world_matrix.1} {parent.Axis5.world_matrix.2}}
        {{parent.Axis5.world_matrix.4} {parent.Axis5.world_matrix.5} {parent.Axis5.world_matrix.6}}
        {{parent.Axis5.world_matrix.8} {parent.Axis5.world_matrix.9} {parent.Axis5.world_matrix.10}}
   }
   name ColorMatrix5
   xpos 0
   ypos 54
   disable {{parent.xzrot==0}}
  }
  Expression {
   temp_name0 nx
   temp_expr0 parent.Plane.pick.r
   temp_name1 ny
   temp_expr1 parent.Plane.pick.g
   temp_name2 nz
   temp_expr2 parent.Plane.pick.b
   channel0 {rgba.red -rgba.green -rgba.blue -rgba.alpha}
   expr0 r*nx
   channel1 {-rgba.red rgba.green -rgba.blue none}
   expr1 g*ny
   channel2 {-rgba.red -rgba.green rgba.blue none}
   expr2 b*nz
   channel3 {none none none -rgba.alpha}
   name Expression1
   xpos 0
   ypos 121
   cached true
  }
  Expression {
   expr3 clamp(r+g+b)
   name Expression3
   xpos 0
   ypos 187
  }
  Invert {
   channels alpha
   name Invert1
   xpos 0
   ypos 249
   disable {{!parent.inv}}
  }
  Expression {
   expr3 pow(a,max(1,parent.exp))
   name Expression4
   xpos 0
   ypos 317
  }
  Grade {
   channels alpha
   blackpoint {{-parent.mblack}}
   white {{parent.mgain}}
   gamma {{max(0.001,parent.mgamma)}}
   white_clamp true
   name Grade1
   xpos 0
   ypos 369
  }
  ChannelMerge {
   inputs 2
   operation multiply
   name ChannelMerge1
   xpos 0
   ypos 444
   disable {{!parent.amask}}
  }
push 0
  Merge2 {
   inputs 2+1
   operation copy
   also_merge all
   name Merge1
   label "\[ expr \{ \[value mix] == 1 ? \" \" : \[concat Mix: \[value mix]] \}]"
   xpos 0
   ypos 544
  }
  Output {
   name Output1
   xpos 0
   ypos 623
  }
 end_group
clone $C162fde00 {
  xpos 1148
  ypos 1088
  selected false
 }
push $N1bafb000
push $N162ff700
push $N12b75200
push 0
 Camera3 {
  inputs 2
  translate {-113.985611 132.3999939 113.985611}
  focal 100
  name Cam45
  xpos -31
  ypos 353
 }
set N1bbf1400 [stack 0]
 Dot {
  name Dot3
  xpos 90
  ypos 377
 }
 Dot {
  name Dot4
  xpos 90
  ypos 694
 }
push $N1bbf1400
push $N1276f180
add_layer {projection_Cam45 projection_Cam45.red projection_Cam45.green projection_Cam45.blue}
 Shuffle2 {
  fromInput1 {
   {0}
   B
  }
  in1 projection_Cam45
  fromInput2 {
   {0}
   B
  }
  mappings "4 projection_Cam45.red 0 0 rgba.red 0 0 projection_Cam45.green 0 1 rgba.green 0 1 projection_Cam45.blue 0 2 rgba.blue 0 2 white -1 -1 rgba.alpha 0 3"
  name Shuffle2
  xpos -170
  ypos 517
 }
 Project3D2 {
  inputs 2
  project_on front
  occlusion_mode world
  name Project3D2
  xpos -41
  ypos 517
 }
clone $C1772aa00 {
  xpos -41
  ypos 541
  selected false
 }
clone $C1772af00 {
  xpos -41
  ypos 600
  selected false
 }
push 0
clone $C1772b400 {
  inputs 3
  xpos -41
  ypos 691
  selected false
 }
 Dot {
  name Dot32
  xpos -6
  ypos 914
 }
set N1bc28c00 [stack 0]
 Dot {
  name Dot33
  xpos -6
  ypos 961
 }
set N1bc29000 [stack 0]
 Invert {
  name Invert2
  xpos 25
  ypos 952
 }
clone $C16364800 {
  inputs 1+1
  xpos 115
  ypos 958
  selected false
 }
 Erode {
  channels all
  size -23
  blur 0.365
  name Erode2
  xpos 199
  ypos 952
 }
push $N1bc28c00
 Group {
  name NormalsRotate10
  onCreate "\nn=nuke.thisNode()\nn\['mblack'].setFlag(0x0000000000000004)\nn\['mgain'].setFlag(0x0000000000000004)\nn\['mgamma'].setFlag(0x0000000000000004)\n"
  tile_color 0xff00ff
  xpos 138
  ypos 911
  addUserKnob {20 User}
  addUserKnob {41 in l "Normals in" t "Select the layer containing the \nnormals" T Shuffle1.in}
  addUserKnob {41 pick l "Pick Plane" T Plane.pick}
  addUserKnob {22 planereset l Reset -STARTLINE T "nuke.thisNode().knob(\"pick\").setValue(0,0)\nnuke.thisNode().knob(\"pick\").setValue(0,1)\nnuke.thisNode().knob(\"pick\").setValue(1,2)"}
  addUserKnob {26 ""}
  addUserKnob {26 divider_2 l "" +STARTLINE T " "}
  addUserKnob {26 manual l "<b>Manual Rotation</b>" -STARTLINE T "  "}
  addUserKnob {22 rotreset l Reset -STARTLINE T "nuke.thisNode().knob(\"yoffset\").setValue(0)\nnuke.thisNode().knob(\"xzrot\").setValue(0)"}
  addUserKnob {7 yoffset l Horizontal t "Rotate around the world Y axis" R -180 180}
  yoffset {{"degrees(atan2(Cam45.world_matrix.2, Cam45.world_matrix.10))"}}
  addUserKnob {7 xzrot l Vertical t "Rotates around the rotated X axis" R -180 180}
  addUserKnob {26 ""}
  addUserKnob {26 matte l "@b;Matte Output" T "      "}
  addUserKnob {6 inv l "Invert    " t "This happens before the matte \ntweaks" -STARTLINE}
  addUserKnob {6 amask l "Mask by Alpha    " -STARTLINE}
  amask true
  addUserKnob {6 unpre l Unpremult -STARTLINE}
  addUserKnob {7 exp l Exponent t "Exponential falloff" R 1 10}
  exp 2
  addUserKnob {22 expreset l Reset -STARTLINE T "nuke.thisNode().knob(\"exp\").setValue(2)"}
  addUserKnob {7 mblack l Black R -1 1}
  addUserKnob {22 mblackreset l Reset -STARTLINE T "nuke.thisNode().knob(\"mblack\").setValue(0)"}
  addUserKnob {7 mgain l White R 0 4}
  mgain 2
  addUserKnob {22 mgainreset l Reset -STARTLINE T "nuke.thisNode().knob(\"mgain\").setValue(1)"}
  addUserKnob {7 mgamma l Gamma R 0 4}
  mgamma 1
  addUserKnob {22 mgammareset l Reset -STARTLINE T "nuke.thisNode().knob(\"mgamma\").setValue(1)"}
  addUserKnob {26 ""}
  addUserKnob {26 "" l mask T ""}
  addUserKnob {41 maskChannelInput l "" -STARTLINE T Merge1.maskChannelInput}
  addUserKnob {41 inject -STARTLINE T Merge1.inject}
  addUserKnob {41 invert_mask l invert -STARTLINE T Merge1.invert_mask}
  addUserKnob {41 fringe -STARTLINE T Merge1.fringe}
  addUserKnob {41 mix T Merge1.mix}
  addUserKnob {20 info l Info}
  addUserKnob {26 infotext l "" +STARTLINE T "W_SuperNormal generates a surface angle based matte using normals.\n\n1. Select the layer containing normals in the dropdown menu.\n2. Enable color picker and pick the point where you want the matte to be white.\n  (I look at the alpha output, hold ctrl+alt and \"glide\" over the surfaces.)\n3. You can also manually rotate the matte. When you colorpick a new point,\n  it is recommended that you reset the manual rotation values to 0.\n"}
  addUserKnob {20 v2_1_group l "v2.1 - Feb 2019" n 1}
  v2_1_group 0
  addUserKnob {26 v2_1_text l "" +STARTLINE T "  -Manual rotation working as originally envisioned: It is more intuitive \n   and faster to reach any desired angle with horizontal(Y) and vertical\n   rotation than with separate XYZ rotations.\n  -General cleanup & refinements.\n"}
  addUserKnob {20 endGroup n -1}
  addUserKnob {20 v2group l "v2.0 - 2018" n 1}
  v2group 0
  addUserKnob {26 v2text l "" +STARTLINE T "  -Adopted a different method for rotating normals shown to me by Daniel Pelc\n  -Simpler math for converting normals into a matte with the help of Erwan Leroy\n"}
  addUserKnob {20 endGroup_1 l endGroup n -1}
  addUserKnob {26 v1_1_text l "" +STARTLINE T "    v1.1 - 2016"}
  addUserKnob {26 ""}
  addUserKnob {26 spacer_1 l "" +STARTLINE T "     "}
  addUserKnob {26 copyright l "&#169;  Wes Heo" -STARTLINE T " "}
 }
  Axis2 {
   inputs 0
   rot_order YXZ
   rotate {0 {-parent.yoffset} 0}
   name Axis10
   label H
   xpos -173
   ypos -163
  }
  Axis2 {
   inputs 0
   rot_order YXZ
   rotate {{parent.xzrot} {-degrees(parent.Plane.picked.g)} 0}
   name Axis2
   label V
   xpos -171
   ypos -62
  }
  Axis2 {
   inputs 0
   rot_order YXZ
   rotate {0 {-parent.Axis2.rotate.y} 0}
   name Axis5
   label V
   xpos -170
   ypos 34
  }
  Input {
   inputs 0
   name Inputmask
   xpos 132
   ypos 544
   number 1
  }
  Input {
   inputs 0
   name N
   xpos 0
   ypos -425
  }
  Shuffle {
   in N
   alpha red2
   out rgb
   name Shuffle1
   xpos 0
   ypos -347
  }
set N1bcb8000 [stack 0]
  Dot {
   name Dot1
   xpos 315
   ypos 289
  }
push $N1bcb8000
  Unpremult {
   name Unpremult1
   xpos 0
   ypos -286
   disable {{!parent.unpre}}
  }
  NoOp {
   name Plane
   xpos 0
   ypos -218
   addUserKnob {20 User}
   addUserKnob {18 pick l "User Picked Plane" R -1 1}
   pick {0 0 1}
   addUserKnob {6 pick_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {20 calc l "Internal Conversions"}
   addUserKnob {18 picked}
   picked {0 {"(atan2(pick.r, pick.b))"} 0}
   addUserKnob {6 picked_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
  }
  ColorMatrix {
   matrix {
    
        {{parent.Axis10.world_matrix.0} {parent.Axis10.world_matrix.1} {parent.Axis10.world_matrix.2}}
        {{parent.Axis10.world_matrix.4} {parent.Axis10.world_matrix.5} {parent.Axis10.world_matrix.6}}
        {{parent.Axis10.world_matrix.8} {parent.Axis10.world_matrix.9} {parent.Axis10.world_matrix.10}}
   }
   name ColorMatrix2
   xpos 0
   ypos -148
   disable {{parent.yoffset==0}}
  }
  ColorMatrix {
   matrix {
    
        {{parent.Axis2.world_matrix.0} {parent.Axis2.world_matrix.1} {parent.Axis2.world_matrix.2}}
        {{parent.Axis2.world_matrix.4} {parent.Axis2.world_matrix.5} {parent.Axis2.world_matrix.6}}
        {{parent.Axis2.world_matrix.8} {parent.Axis2.world_matrix.9} {parent.Axis2.world_matrix.10}}
   }
   name ColorMatrix3
   xpos 0
   ypos -42
   disable {{parent.xzrot==0}}
  }
  ColorMatrix {
   matrix {
    
        {{parent.Axis5.world_matrix.0} {parent.Axis5.world_matrix.1} {parent.Axis5.world_matrix.2}}
        {{parent.Axis5.world_matrix.4} {parent.Axis5.world_matrix.5} {parent.Axis5.world_matrix.6}}
        {{parent.Axis5.world_matrix.8} {parent.Axis5.world_matrix.9} {parent.Axis5.world_matrix.10}}
   }
   name ColorMatrix5
   xpos 0
   ypos 54
   disable {{parent.xzrot==0}}
  }
  Expression {
   temp_name0 nx
   temp_expr0 parent.Plane.pick.r
   temp_name1 ny
   temp_expr1 parent.Plane.pick.g
   temp_name2 nz
   temp_expr2 parent.Plane.pick.b
   channel0 {rgba.red -rgba.green -rgba.blue -rgba.alpha}
   expr0 r*nx
   channel1 {-rgba.red rgba.green -rgba.blue none}
   expr1 g*ny
   channel2 {-rgba.red -rgba.green rgba.blue none}
   expr2 b*nz
   channel3 {none none none -rgba.alpha}
   name Expression1
   xpos 0
   ypos 121
   cached true
  }
  Expression {
   expr3 clamp(r+g+b)
   name Expression3
   xpos 0
   ypos 187
  }
  Invert {
   channels alpha
   name Invert1
   xpos 0
   ypos 249
   disable {{!parent.inv}}
  }
  Expression {
   expr3 pow(a,max(1,parent.exp))
   name Expression4
   xpos 0
   ypos 317
  }
  Grade {
   channels alpha
   blackpoint {{-parent.mblack}}
   white {{parent.mgain}}
   gamma {{max(0.001,parent.mgamma)}}
   white_clamp true
   name Grade1
   xpos 0
   ypos 369
  }
  ChannelMerge {
   inputs 2
   operation multiply
   name ChannelMerge1
   xpos 0
   ypos 444
   disable {{!parent.amask}}
  }
push 0
  Merge2 {
   inputs 2+1
   operation copy
   also_merge all
   name Merge1
   label "\[ expr \{ \[value mix] == 1 ? \" \" : \[concat Mix: \[value mix]] \}]"
   xpos 0
   ypos 544
  }
  Output {
   name Output1
   xpos 0
   ypos 623
  }
 end_group
 Dot {
  name Dot34
  xpos 313
  ypos 914
 }
 Grade {
  inputs 1+1
  channels rgba
  white 0
  name Grade4
  xpos 279
  ypos 958
 }
 Dot {
  name Dot35
  xpos 313
  ypos 1025
 }
 Dot {
  name Dot36
  xpos 706
  ypos 1025
 }
 Dot {
  name Dot37
  xpos 706
  ypos 1128
 }
push $N12b75200
push 0
 Camera3 {
  inputs 2
  translate {-161.1999969 132.3999939 9.870653014e-15}
  focal 100
  name Cam90
  xpos 512
  ypos 351
 }
set N1bd35900 [stack 0]
 Dot {
  name Dot8
  xpos 633
  ypos 375
 }
 Dot {
  name Dot9
  xpos 633
  ypos 692
 }
push $N1bd35900
push $N1276f180
add_layer {projection_Cam90 projection_Cam90.red projection_Cam90.green projection_Cam90.blue}
 Shuffle2 {
  fromInput1 {
   {0}
   B
  }
  in1 projection_Cam90
  fromInput2 {
   {0}
   B
  }
  mappings "4 projection_Cam90.red 0 0 rgba.red 0 0 projection_Cam90.green 0 1 rgba.green 0 1 projection_Cam90.blue 0 2 rgba.blue 0 2 white -1 -1 rgba.alpha 0 3"
  name Shuffle3
  xpos 384
  ypos 515
 }
 Project3D2 {
  inputs 2
  project_on front
  occlusion_mode world
  name Project3D3
  xpos 502
  ypos 515
 }
clone $C1772aa00 {
  xpos 502
  ypos 539
  selected false
 }
clone $C1772af00 {
  xpos 502
  ypos 596
  selected false
 }
push 0
clone $C1772b400 {
  inputs 3
  xpos 502
  ypos 689
  selected false
 }
 Dot {
  name Dot10
  xpos 536
  ypos 1062
 }
set N1bd2dc00 [stack 0]
 Group {
  name NormalsRotate4
  onCreate "\nn=nuke.thisNode()\nn\['mblack'].setFlag(0x0000000000000004)\nn\['mgain'].setFlag(0x0000000000000004)\nn\['mgamma'].setFlag(0x0000000000000004)\n"
  tile_color 0xff00ff
  xpos 592
  ypos 1059
  addUserKnob {20 User}
  addUserKnob {41 in l "Normals in" t "Select the layer containing the \nnormals" T Shuffle1.in}
  addUserKnob {41 pick l "Pick Plane" T Plane.pick}
  addUserKnob {22 planereset l Reset -STARTLINE T "nuke.thisNode().knob(\"pick\").setValue(0,0)\nnuke.thisNode().knob(\"pick\").setValue(0,1)\nnuke.thisNode().knob(\"pick\").setValue(1,2)"}
  addUserKnob {26 ""}
  addUserKnob {26 divider_2 l "" +STARTLINE T " "}
  addUserKnob {26 manual l "<b>Manual Rotation</b>" -STARTLINE T "  "}
  addUserKnob {22 rotreset l Reset -STARTLINE T "nuke.thisNode().knob(\"yoffset\").setValue(0)\nnuke.thisNode().knob(\"xzrot\").setValue(0)"}
  addUserKnob {7 yoffset l Horizontal t "Rotate around the world Y axis" R -180 180}
  yoffset {{"degrees(atan2(Cam90.world_matrix.2, Cam90.world_matrix.10))-15"}}
  addUserKnob {7 xzrot l Vertical t "Rotates around the rotated X axis" R -180 180}
  addUserKnob {26 ""}
  addUserKnob {26 matte l "@b;Matte Output" T "      "}
  addUserKnob {6 inv l "Invert    " t "This happens before the matte \ntweaks" -STARTLINE}
  addUserKnob {6 amask l "Mask by Alpha    " -STARTLINE}
  addUserKnob {6 unpre l Unpremult -STARTLINE}
  addUserKnob {7 exp l Exponent t "Exponential falloff" R 1 10}
  exp 1.25
  addUserKnob {22 expreset l Reset -STARTLINE T "nuke.thisNode().knob(\"exp\").setValue(2)"}
  addUserKnob {7 mblack l Black R -1 1}
  addUserKnob {22 mblackreset l Reset -STARTLINE T "nuke.thisNode().knob(\"mblack\").setValue(0)"}
  addUserKnob {7 mgain l White R 0 4}
  mgain 4
  addUserKnob {22 mgainreset l Reset -STARTLINE T "nuke.thisNode().knob(\"mgain\").setValue(1)"}
  addUserKnob {7 mgamma l Gamma R 0 4}
  mgamma 1
  addUserKnob {22 mgammareset l Reset -STARTLINE T "nuke.thisNode().knob(\"mgamma\").setValue(1)"}
  addUserKnob {26 ""}
  addUserKnob {26 "" l mask T ""}
  addUserKnob {41 maskChannelInput l "" -STARTLINE T Merge1.maskChannelInput}
  addUserKnob {41 inject -STARTLINE T Merge1.inject}
  addUserKnob {41 invert_mask l invert -STARTLINE T Merge1.invert_mask}
  addUserKnob {41 fringe -STARTLINE T Merge1.fringe}
  addUserKnob {41 mix T Merge1.mix}
  addUserKnob {20 info l Info}
  addUserKnob {26 infotext l "" +STARTLINE T "W_SuperNormal generates a surface angle based matte using normals.\n\n1. Select the layer containing normals in the dropdown menu.\n2. Enable color picker and pick the point where you want the matte to be white.\n  (I look at the alpha output, hold ctrl+alt and \"glide\" over the surfaces.)\n3. You can also manually rotate the matte. When you colorpick a new point,\n  it is recommended that you reset the manual rotation values to 0.\n"}
  addUserKnob {20 v2_1_group l "v2.1 - Feb 2019" n 1}
  v2_1_group 0
  addUserKnob {26 v2_1_text l "" +STARTLINE T "  -Manual rotation working as originally envisioned: It is more intuitive \n   and faster to reach any desired angle with horizontal(Y) and vertical\n   rotation than with separate XYZ rotations.\n  -General cleanup & refinements.\n"}
  addUserKnob {20 endGroup n -1}
  addUserKnob {20 v2group l "v2.0 - 2018" n 1}
  v2group 0
  addUserKnob {26 v2text l "" +STARTLINE T "  -Adopted a different method for rotating normals shown to me by Daniel Pelc\n  -Simpler math for converting normals into a matte with the help of Erwan Leroy\n"}
  addUserKnob {20 endGroup_1 l endGroup n -1}
  addUserKnob {26 v1_1_text l "" +STARTLINE T "    v1.1 - 2016"}
  addUserKnob {26 ""}
  addUserKnob {26 spacer_1 l "" +STARTLINE T "     "}
  addUserKnob {26 copyright l "&#169;  Wes Heo" -STARTLINE T " "}
 }
  Axis2 {
   inputs 0
   rot_order YXZ
   rotate {0 {-parent.yoffset} 0}
   name Axis10
   label H
   xpos -173
   ypos -163
  }
  Axis2 {
   inputs 0
   rot_order YXZ
   rotate {{parent.xzrot} {-degrees(parent.Plane.picked.g)} 0}
   name Axis2
   label V
   xpos -171
   ypos -62
  }
  Axis2 {
   inputs 0
   rot_order YXZ
   rotate {0 {-parent.Axis2.rotate.y} 0}
   name Axis5
   label V
   xpos -170
   ypos 34
  }
  Input {
   inputs 0
   name Inputmask
   xpos 132
   ypos 544
   number 1
  }
  Input {
   inputs 0
   name N
   xpos 0
   ypos -425
  }
  Shuffle {
   in N
   alpha red2
   out rgb
   name Shuffle1
   xpos 0
   ypos -347
  }
set N1bd94f00 [stack 0]
  Dot {
   name Dot1
   xpos 315
   ypos 289
  }
push $N1bd94f00
  Unpremult {
   name Unpremult1
   xpos 0
   ypos -286
   disable {{!parent.unpre}}
  }
  NoOp {
   name Plane
   xpos 0
   ypos -218
   addUserKnob {20 User}
   addUserKnob {18 pick l "User Picked Plane" R -1 1}
   pick {0 0 1}
   addUserKnob {6 pick_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {20 calc l "Internal Conversions"}
   addUserKnob {18 picked}
   picked {0 {"(atan2(pick.r, pick.b))"} 0}
   addUserKnob {6 picked_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
  }
  ColorMatrix {
   matrix {
    
        {{parent.Axis10.world_matrix.0} {parent.Axis10.world_matrix.1} {parent.Axis10.world_matrix.2}}
        {{parent.Axis10.world_matrix.4} {parent.Axis10.world_matrix.5} {parent.Axis10.world_matrix.6}}
        {{parent.Axis10.world_matrix.8} {parent.Axis10.world_matrix.9} {parent.Axis10.world_matrix.10}}
   }
   name ColorMatrix2
   xpos 0
   ypos -148
   disable {{parent.yoffset==0}}
  }
  ColorMatrix {
   matrix {
    
        {{parent.Axis2.world_matrix.0} {parent.Axis2.world_matrix.1} {parent.Axis2.world_matrix.2}}
        {{parent.Axis2.world_matrix.4} {parent.Axis2.world_matrix.5} {parent.Axis2.world_matrix.6}}
        {{parent.Axis2.world_matrix.8} {parent.Axis2.world_matrix.9} {parent.Axis2.world_matrix.10}}
   }
   name ColorMatrix3
   xpos 0
   ypos -42
   disable {{parent.xzrot==0}}
  }
  ColorMatrix {
   matrix {
    
        {{parent.Axis5.world_matrix.0} {parent.Axis5.world_matrix.1} {parent.Axis5.world_matrix.2}}
        {{parent.Axis5.world_matrix.4} {parent.Axis5.world_matrix.5} {parent.Axis5.world_matrix.6}}
        {{parent.Axis5.world_matrix.8} {parent.Axis5.world_matrix.9} {parent.Axis5.world_matrix.10}}
   }
   name ColorMatrix5
   xpos 0
   ypos 54
   disable {{parent.xzrot==0}}
  }
  Expression {
   temp_name0 nx
   temp_expr0 parent.Plane.pick.r
   temp_name1 ny
   temp_expr1 parent.Plane.pick.g
   temp_name2 nz
   temp_expr2 parent.Plane.pick.b
   channel0 {rgba.red -rgba.green -rgba.blue -rgba.alpha}
   expr0 r*nx
   channel1 {-rgba.red rgba.green -rgba.blue none}
   expr1 g*ny
   channel2 {-rgba.red -rgba.green rgba.blue none}
   expr2 b*nz
   channel3 {none none none -rgba.alpha}
   name Expression1
   xpos 0
   ypos 121
   cached true
  }
  Expression {
   expr3 clamp(r+g+b)
   name Expression3
   xpos 0
   ypos 187
  }
  Invert {
   channels alpha
   name Invert1
   xpos 0
   ypos 249
   disable {{!parent.inv}}
  }
  Expression {
   expr3 pow(a,max(1,parent.exp))
   name Expression4
   xpos 0
   ypos 317
  }
  Grade {
   channels alpha
   blackpoint {{-parent.mblack}}
   white {{parent.mgain}}
   gamma {{max(0.001,parent.mgamma)}}
   white_clamp true
   name Grade1
   xpos 0
   ypos 369
  }
  ChannelMerge {
   inputs 2
   operation multiply
   name ChannelMerge1
   xpos 0
   ypos 444
   disable {{!parent.amask}}
  }
push 0
  Merge2 {
   inputs 2+1
   operation copy
   also_merge all
   name Merge1
   label "\[ expr \{ \[value mix] == 1 ? \" \" : \[concat Mix: \[value mix]] \}]"
   xpos 0
   ypos 544
  }
  Output {
   name Output1
   xpos 0
   ypos 623
  }
 end_group
clone $C162fde00 {
  xpos 592
  ypos 1083
  selected false
 }
 Grade {
  inputs 1+1
  channels rgba
  white 0
  name Grade5
  xpos 592
  ypos 1125
 }
push $N1bd2dc00
push $N162ff700
push $N164bb400
 Dot {
  name Dot6
  xpos -525
  ypos 910
 }
set N1bdccc00 [stack 0]
 Dot {
  name Dot26
  xpos -525
  ypos 957
 }
set N1bdcd000 [stack 0]
 Invert {
  name Invert1
  xpos -501
  ypos 948
 }
clone $C16364800 {
  inputs 1+1
  xpos -412
  ypos 954
  selected false
 }
 Erode {
  channels all
  size -23
  blur 0.365
  name Erode1
  xpos -328
  ypos 948
 }
push $N1bdccc00
 Group {
  name NormalsRotate2
  onCreate "\nn=nuke.thisNode()\nn\['mblack'].setFlag(0x0000000000000004)\nn\['mgain'].setFlag(0x0000000000000004)\nn\['mgamma'].setFlag(0x0000000000000004)\n"
  tile_color 0xff00ff
  xpos -367
  ypos 907
  addUserKnob {20 User}
  addUserKnob {41 in l "Normals in" t "Select the layer containing the \nnormals" T Shuffle1.in}
  addUserKnob {41 pick l "Pick Plane" T Plane.pick}
  addUserKnob {22 planereset l Reset -STARTLINE T "nuke.thisNode().knob(\"pick\").setValue(0,0)\nnuke.thisNode().knob(\"pick\").setValue(0,1)\nnuke.thisNode().knob(\"pick\").setValue(1,2)"}
  addUserKnob {26 ""}
  addUserKnob {26 divider_2 l "" +STARTLINE T " "}
  addUserKnob {26 manual l "<b>Manual Rotation</b>" -STARTLINE T "  "}
  addUserKnob {22 rotreset l Reset -STARTLINE T "nuke.thisNode().knob(\"yoffset\").setValue(0)\nnuke.thisNode().knob(\"xzrot\").setValue(0)"}
  addUserKnob {7 yoffset l Horizontal t "Rotate around the world Y axis" R -180 180}
  yoffset {{"degrees(atan2(CamInit.world_matrix.2, CamInit.world_matrix.10))+10"}}
  addUserKnob {7 xzrot l Vertical t "Rotates around the rotated X axis" R -180 180}
  addUserKnob {26 ""}
  addUserKnob {26 matte l "@b;Matte Output" T "      "}
  addUserKnob {6 inv l "Invert    " t "This happens before the matte \ntweaks" -STARTLINE}
  addUserKnob {6 amask l "Mask by Alpha    " -STARTLINE}
  amask true
  addUserKnob {6 unpre l Unpremult -STARTLINE}
  addUserKnob {7 exp l Exponent t "Exponential falloff" R 1 10}
  exp 2
  addUserKnob {22 expreset l Reset -STARTLINE T "nuke.thisNode().knob(\"exp\").setValue(2)"}
  addUserKnob {7 mblack l Black R -1 1}
  addUserKnob {22 mblackreset l Reset -STARTLINE T "nuke.thisNode().knob(\"mblack\").setValue(0)"}
  addUserKnob {7 mgain l White R 0 4}
  mgain 2
  addUserKnob {22 mgainreset l Reset -STARTLINE T "nuke.thisNode().knob(\"mgain\").setValue(1)"}
  addUserKnob {7 mgamma l Gamma R 0 4}
  mgamma 1
  addUserKnob {22 mgammareset l Reset -STARTLINE T "nuke.thisNode().knob(\"mgamma\").setValue(1)"}
  addUserKnob {26 ""}
  addUserKnob {26 "" l mask T ""}
  addUserKnob {41 maskChannelInput l "" -STARTLINE T Merge1.maskChannelInput}
  addUserKnob {41 inject -STARTLINE T Merge1.inject}
  addUserKnob {41 invert_mask l invert -STARTLINE T Merge1.invert_mask}
  addUserKnob {41 fringe -STARTLINE T Merge1.fringe}
  addUserKnob {41 mix T Merge1.mix}
  addUserKnob {20 info l Info}
  addUserKnob {26 infotext l "" +STARTLINE T "W_SuperNormal generates a surface angle based matte using normals.\n\n1. Select the layer containing normals in the dropdown menu.\n2. Enable color picker and pick the point where you want the matte to be white.\n  (I look at the alpha output, hold ctrl+alt and \"glide\" over the surfaces.)\n3. You can also manually rotate the matte. When you colorpick a new point,\n  it is recommended that you reset the manual rotation values to 0.\n"}
  addUserKnob {20 v2_1_group l "v2.1 - Feb 2019" n 1}
  v2_1_group 0
  addUserKnob {26 v2_1_text l "" +STARTLINE T "  -Manual rotation working as originally envisioned: It is more intuitive \n   and faster to reach any desired angle with horizontal(Y) and vertical\n   rotation than with separate XYZ rotations.\n  -General cleanup & refinements.\n"}
  addUserKnob {20 endGroup n -1}
  addUserKnob {20 v2group l "v2.0 - 2018" n 1}
  v2group 0
  addUserKnob {26 v2text l "" +STARTLINE T "  -Adopted a different method for rotating normals shown to me by Daniel Pelc\n  -Simpler math for converting normals into a matte with the help of Erwan Leroy\n"}
  addUserKnob {20 endGroup_1 l endGroup n -1}
  addUserKnob {26 v1_1_text l "" +STARTLINE T "    v1.1 - 2016"}
  addUserKnob {26 ""}
  addUserKnob {26 spacer_1 l "" +STARTLINE T "     "}
  addUserKnob {26 copyright l "&#169;  Wes Heo" -STARTLINE T " "}
 }
  Axis2 {
   inputs 0
   rot_order YXZ
   rotate {0 {-parent.yoffset} 0}
   name Axis10
   label H
   xpos -173
   ypos -163
  }
  Axis2 {
   inputs 0
   rot_order YXZ
   rotate {{parent.xzrot} {-degrees(parent.Plane.picked.g)} 0}
   name Axis2
   label V
   xpos -171
   ypos -62
  }
  Axis2 {
   inputs 0
   rot_order YXZ
   rotate {0 {-parent.Axis2.rotate.y} 0}
   name Axis5
   label V
   xpos -170
   ypos 34
  }
  Input {
   inputs 0
   name Inputmask
   xpos 132
   ypos 544
   number 1
  }
  Input {
   inputs 0
   name N
   xpos 0
   ypos -425
  }
  Shuffle {
   in N
   alpha red2
   out rgb
   name Shuffle1
   xpos 0
   ypos -347
  }
set N1be5f200 [stack 0]
  Dot {
   name Dot1
   xpos 315
   ypos 289
  }
push $N1be5f200
  Unpremult {
   name Unpremult1
   xpos 0
   ypos -286
   disable {{!parent.unpre}}
  }
  NoOp {
   name Plane
   xpos 0
   ypos -218
   addUserKnob {20 User}
   addUserKnob {18 pick l "User Picked Plane" R -1 1}
   pick {0 0 1}
   addUserKnob {6 pick_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {20 calc l "Internal Conversions"}
   addUserKnob {18 picked}
   picked {0 {"(atan2(pick.r, pick.b))"} 0}
   addUserKnob {6 picked_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
  }
  ColorMatrix {
   matrix {
    
        {{parent.Axis10.world_matrix.0} {parent.Axis10.world_matrix.1} {parent.Axis10.world_matrix.2}}
        {{parent.Axis10.world_matrix.4} {parent.Axis10.world_matrix.5} {parent.Axis10.world_matrix.6}}
        {{parent.Axis10.world_matrix.8} {parent.Axis10.world_matrix.9} {parent.Axis10.world_matrix.10}}
   }
   name ColorMatrix2
   xpos 0
   ypos -148
   disable {{parent.yoffset==0}}
  }
  ColorMatrix {
   matrix {
    
        {{parent.Axis2.world_matrix.0} {parent.Axis2.world_matrix.1} {parent.Axis2.world_matrix.2}}
        {{parent.Axis2.world_matrix.4} {parent.Axis2.world_matrix.5} {parent.Axis2.world_matrix.6}}
        {{parent.Axis2.world_matrix.8} {parent.Axis2.world_matrix.9} {parent.Axis2.world_matrix.10}}
   }
   name ColorMatrix3
   xpos 0
   ypos -42
   disable {{parent.xzrot==0}}
  }
  ColorMatrix {
   matrix {
    
        {{parent.Axis5.world_matrix.0} {parent.Axis5.world_matrix.1} {parent.Axis5.world_matrix.2}}
        {{parent.Axis5.world_matrix.4} {parent.Axis5.world_matrix.5} {parent.Axis5.world_matrix.6}}
        {{parent.Axis5.world_matrix.8} {parent.Axis5.world_matrix.9} {parent.Axis5.world_matrix.10}}
   }
   name ColorMatrix5
   xpos 0
   ypos 54
   disable {{parent.xzrot==0}}
  }
  Expression {
   temp_name0 nx
   temp_expr0 parent.Plane.pick.r
   temp_name1 ny
   temp_expr1 parent.Plane.pick.g
   temp_name2 nz
   temp_expr2 parent.Plane.pick.b
   channel0 {rgba.red -rgba.green -rgba.blue -rgba.alpha}
   expr0 r*nx
   channel1 {-rgba.red rgba.green -rgba.blue none}
   expr1 g*ny
   channel2 {-rgba.red -rgba.green rgba.blue none}
   expr2 b*nz
   channel3 {none none none -rgba.alpha}
   name Expression1
   xpos 0
   ypos 121
   cached true
  }
  Expression {
   expr3 clamp(r+g+b)
   name Expression3
   xpos 0
   ypos 187
  }
  Invert {
   channels alpha
   name Invert1
   xpos 0
   ypos 249
   disable {{!parent.inv}}
  }
  Expression {
   expr3 pow(a,max(1,parent.exp))
   name Expression4
   xpos 0
   ypos 317
  }
  Grade {
   channels alpha
   blackpoint {{-parent.mblack}}
   white {{parent.mgain}}
   gamma {{max(0.001,parent.mgamma)}}
   white_clamp true
   name Grade1
   xpos 0
   ypos 369
  }
  ChannelMerge {
   inputs 2
   operation multiply
   name ChannelMerge1
   xpos 0
   ypos 444
   disable {{!parent.amask}}
  }
push 0
  Merge2 {
   inputs 2+1
   operation copy
   also_merge all
   name Merge1
   label "\[ expr \{ \[value mix] == 1 ? \" \" : \[concat Mix: \[value mix]] \}]"
   xpos 0
   ypos 544
  }
  Output {
   name Output1
   xpos 0
   ypos 623
  }
 end_group
 Dot {
  name Dot28
  xpos -206
  ypos 910
 }
 Grade {
  inputs 1+1
  channels rgba
  white 0
  name Grade3
  xpos -240
  ypos 954
 }
 Dot {
  name Dot31
  xpos -206
  ypos 1021
 }
 Dot {
  name Dot30
  xpos 187
  ypos 1021
 }
 Dot {
  name Dot29
  xpos 187
  ypos 1124
 }
push $N1bc29000
 Dot {
  name Dot7
  xpos -7
  ypos 1064
 }
set N1bf17000 [stack 0]
 Group {
  name NormalsRotate1
  onCreate "\nn=nuke.thisNode()\nn\['mblack'].setFlag(0x0000000000000004)\nn\['mgain'].setFlag(0x0000000000000004)\nn\['mgamma'].setFlag(0x0000000000000004)\n"
  tile_color 0xff00ff
  xpos 49
  ypos 1061
  addUserKnob {20 User}
  addUserKnob {41 in l "Normals in" t "Select the layer containing the \nnormals" T Shuffle1.in}
  addUserKnob {41 pick l "Pick Plane" T Plane.pick}
  addUserKnob {22 planereset l Reset -STARTLINE T "nuke.thisNode().knob(\"pick\").setValue(0,0)\nnuke.thisNode().knob(\"pick\").setValue(0,1)\nnuke.thisNode().knob(\"pick\").setValue(1,2)"}
  addUserKnob {26 ""}
  addUserKnob {26 divider_2 l "" +STARTLINE T " "}
  addUserKnob {26 manual l "<b>Manual Rotation</b>" -STARTLINE T "  "}
  addUserKnob {22 rotreset l Reset -STARTLINE T "nuke.thisNode().knob(\"yoffset\").setValue(0)\nnuke.thisNode().knob(\"xzrot\").setValue(0)"}
  addUserKnob {7 yoffset l Horizontal t "Rotate around the world Y axis" R -180 180}
  yoffset {{"degrees(atan2(Cam45.world_matrix.2, Cam45.world_matrix.10))"}}
  addUserKnob {7 xzrot l Vertical t "Rotates around the rotated X axis" R -180 180}
  addUserKnob {26 ""}
  addUserKnob {26 matte l "@b;Matte Output" T "      "}
  addUserKnob {6 inv l "Invert    " t "This happens before the matte \ntweaks" -STARTLINE}
  addUserKnob {6 amask l "Mask by Alpha    " -STARTLINE}
  addUserKnob {6 unpre l Unpremult -STARTLINE}
  addUserKnob {7 exp l Exponent t "Exponential falloff" R 1 10}
  exp 1
  addUserKnob {22 expreset l Reset -STARTLINE T "nuke.thisNode().knob(\"exp\").setValue(2)"}
  addUserKnob {7 mblack l Black R -1 1}
  mblack -0.07
  addUserKnob {22 mblackreset l Reset -STARTLINE T "nuke.thisNode().knob(\"mblack\").setValue(0)"}
  addUserKnob {7 mgain l White R 0 4}
  mgain 6
  addUserKnob {22 mgainreset l Reset -STARTLINE T "nuke.thisNode().knob(\"mgain\").setValue(1)"}
  addUserKnob {7 mgamma l Gamma R 0 4}
  mgamma 1
  addUserKnob {22 mgammareset l Reset -STARTLINE T "nuke.thisNode().knob(\"mgamma\").setValue(1)"}
  addUserKnob {26 ""}
  addUserKnob {26 "" l mask T ""}
  addUserKnob {41 maskChannelInput l "" -STARTLINE T Merge1.maskChannelInput}
  addUserKnob {41 inject -STARTLINE T Merge1.inject}
  addUserKnob {41 invert_mask l invert -STARTLINE T Merge1.invert_mask}
  addUserKnob {41 fringe -STARTLINE T Merge1.fringe}
  addUserKnob {41 mix T Merge1.mix}
  addUserKnob {20 info l Info}
  addUserKnob {26 infotext l "" +STARTLINE T "W_SuperNormal generates a surface angle based matte using normals.\n\n1. Select the layer containing normals in the dropdown menu.\n2. Enable color picker and pick the point where you want the matte to be white.\n  (I look at the alpha output, hold ctrl+alt and \"glide\" over the surfaces.)\n3. You can also manually rotate the matte. When you colorpick a new point,\n  it is recommended that you reset the manual rotation values to 0.\n"}
  addUserKnob {20 v2_1_group l "v2.1 - Feb 2019" n 1}
  v2_1_group 0
  addUserKnob {26 v2_1_text l "" +STARTLINE T "  -Manual rotation working as originally envisioned: It is more intuitive \n   and faster to reach any desired angle with horizontal(Y) and vertical\n   rotation than with separate XYZ rotations.\n  -General cleanup & refinements.\n"}
  addUserKnob {20 endGroup n -1}
  addUserKnob {20 v2group l "v2.0 - 2018" n 1}
  v2group 0
  addUserKnob {26 v2text l "" +STARTLINE T "  -Adopted a different method for rotating normals shown to me by Daniel Pelc\n  -Simpler math for converting normals into a matte with the help of Erwan Leroy\n"}
  addUserKnob {20 endGroup_1 l endGroup n -1}
  addUserKnob {26 v1_1_text l "" +STARTLINE T "    v1.1 - 2016"}
  addUserKnob {26 ""}
  addUserKnob {26 spacer_1 l "" +STARTLINE T "     "}
  addUserKnob {26 copyright l "&#169;  Wes Heo" -STARTLINE T " "}
 }
  Axis2 {
   inputs 0
   rot_order YXZ
   rotate {0 {-parent.yoffset} 0}
   name Axis10
   label H
   xpos -173
   ypos -163
  }
  Axis2 {
   inputs 0
   rot_order YXZ
   rotate {{parent.xzrot} {-degrees(parent.Plane.picked.g)} 0}
   name Axis2
   label V
   xpos -171
   ypos -62
  }
  Axis2 {
   inputs 0
   rot_order YXZ
   rotate {0 {-parent.Axis2.rotate.y} 0}
   name Axis5
   label V
   xpos -170
   ypos 34
  }
  Input {
   inputs 0
   name Inputmask
   xpos 132
   ypos 544
   number 1
  }
  Input {
   inputs 0
   name N
   xpos 0
   ypos -425
  }
  Shuffle {
   in N
   alpha red2
   out rgb
   name Shuffle1
   xpos 0
   ypos -347
  }
set N1bf1be00 [stack 0]
  Dot {
   name Dot1
   xpos 315
   ypos 289
  }
push $N1bf1be00
  Unpremult {
   name Unpremult1
   xpos 0
   ypos -286
   disable {{!parent.unpre}}
  }
  NoOp {
   name Plane
   xpos 0
   ypos -218
   addUserKnob {20 User}
   addUserKnob {18 pick l "User Picked Plane" R -1 1}
   pick {0 0 1}
   addUserKnob {6 pick_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {20 calc l "Internal Conversions"}
   addUserKnob {18 picked}
   picked {0 {"(atan2(pick.r, pick.b))"} 0}
   addUserKnob {6 picked_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
  }
  ColorMatrix {
   matrix {
    
        {{parent.Axis10.world_matrix.0} {parent.Axis10.world_matrix.1} {parent.Axis10.world_matrix.2}}
        {{parent.Axis10.world_matrix.4} {parent.Axis10.world_matrix.5} {parent.Axis10.world_matrix.6}}
        {{parent.Axis10.world_matrix.8} {parent.Axis10.world_matrix.9} {parent.Axis10.world_matrix.10}}
   }
   name ColorMatrix2
   xpos 0
   ypos -148
   disable {{parent.yoffset==0}}
  }
  ColorMatrix {
   matrix {
    
        {{parent.Axis2.world_matrix.0} {parent.Axis2.world_matrix.1} {parent.Axis2.world_matrix.2}}
        {{parent.Axis2.world_matrix.4} {parent.Axis2.world_matrix.5} {parent.Axis2.world_matrix.6}}
        {{parent.Axis2.world_matrix.8} {parent.Axis2.world_matrix.9} {parent.Axis2.world_matrix.10}}
   }
   name ColorMatrix3
   xpos 0
   ypos -42
   disable {{parent.xzrot==0}}
  }
  ColorMatrix {
   matrix {
    
        {{parent.Axis5.world_matrix.0} {parent.Axis5.world_matrix.1} {parent.Axis5.world_matrix.2}}
        {{parent.Axis5.world_matrix.4} {parent.Axis5.world_matrix.5} {parent.Axis5.world_matrix.6}}
        {{parent.Axis5.world_matrix.8} {parent.Axis5.world_matrix.9} {parent.Axis5.world_matrix.10}}
   }
   name ColorMatrix5
   xpos 0
   ypos 54
   disable {{parent.xzrot==0}}
  }
  Expression {
   temp_name0 nx
   temp_expr0 parent.Plane.pick.r
   temp_name1 ny
   temp_expr1 parent.Plane.pick.g
   temp_name2 nz
   temp_expr2 parent.Plane.pick.b
   channel0 {rgba.red -rgba.green -rgba.blue -rgba.alpha}
   expr0 r*nx
   channel1 {-rgba.red rgba.green -rgba.blue none}
   expr1 g*ny
   channel2 {-rgba.red -rgba.green rgba.blue none}
   expr2 b*nz
   channel3 {none none none -rgba.alpha}
   name Expression1
   xpos 0
   ypos 121
   cached true
  }
  Expression {
   expr3 clamp(r+g+b)
   name Expression3
   xpos 0
   ypos 187
  }
  Invert {
   channels alpha
   name Invert1
   xpos 0
   ypos 249
   disable {{!parent.inv}}
  }
  Expression {
   expr3 pow(a,max(1,parent.exp))
   name Expression4
   xpos 0
   ypos 317
  }
  Grade {
   channels alpha
   blackpoint {{-parent.mblack}}
   white {{parent.mgain}}
   gamma {{max(0.001,parent.mgamma)}}
   white_clamp true
   name Grade1
   xpos 0
   ypos 369
  }
  ChannelMerge {
   inputs 2
   operation multiply
   name ChannelMerge1
   xpos 0
   ypos 444
   disable {{!parent.amask}}
  }
push 0
  Merge2 {
   inputs 2+1
   operation copy
   also_merge all
   name Merge1
   label "\[ expr \{ \[value mix] == 1 ? \" \" : \[concat Mix: \[value mix]] \}]"
   xpos 0
   ypos 544
  }
  Output {
   name Output1
   xpos 0
   ypos 623
  }
 end_group
clone $C162fde00 {
  xpos 49
  ypos 1085
  selected false
 }
 Grade {
  inputs 1+1
  channels rgba
  white 0
  name Grade2
  xpos 49
  ypos 1121
 }
push $N1bf17000
push $N1bdcd000
 Dot {
  name Dot5
  xpos -525
  ypos 1167
 }
 Merge2 {
  inputs 2+1
  name Merge1
  xpos -41
  ypos 1162
 }
 Merge2 {
  inputs 2+1
  name Merge2
  xpos 502
  ypos 1162
 }
 Merge2 {
  inputs 2+1
  name Merge3
  xpos 1054
  ypos 1162
 }
 Merge2 {
  inputs 2+1
  name Merge7
  xpos 1655
  ypos 1162
 }
 Merge2 {
  inputs 2+1
  name Merge6
  xpos 2198
  ypos 1162
 }
 Merge2 {
  inputs 2+1
  name Merge5
  xpos 2618
  ypos 1162
 }
 Merge2 {
  inputs 2+1
  name Merge4
  xpos 3034
  ypos 1162
 }
 EdgeExtend {
  name EdgeExtend1
  xpos 3034
  ypos 1302
  slice_width 5
  blurResult 10
 }
 Dot {
  name Dot27
  xpos 3068
  ypos 1372
 }
set N1c171000 [stack 0]
 Keyer {
  operation "luminance key"
  range {0.5988737658 1 1 1}
  name Keyer1
  xpos 3124
  ypos 1363
 }
push $N1c171000
 Grade {
  inputs 1+1
  white 0.72
  mix 0.52
  name Grade1
  xpos 3034
  ypos 1426
 }
 Dot {
  name Dot50
  xpos 3068
  ypos 1465
 }
set N1c171400 [stack 0]
 Keyer {
  operation "luminance key"
  range {0.6627105376 0.9503800409 1 1}
  name Keyer2
  xpos 3124
  ypos 1456
 }
push $N1c171400
 Grade {
  inputs 1+1
  white 0.72
  mix 0.67
  name Grade11
  xpos 3034
  ypos 1519
 }
 Output {
  name Output1
  xpos 3034
  ypos 1577
 }
clone $C1772af00 {
  inputs 0
  xpos -779
  ypos -63
  selected false
 }
 Input {
  inputs 0
  name geo
  xpos -376
  ypos -28
  number 2
 }
end_group
