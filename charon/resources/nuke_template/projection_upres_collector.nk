Group {
 inputs 1
 name Projection_UpRes_Collector
 addUserKnob {20 User}
 addUserKnob {7 camera_count l "Number of Cameras"}
 camera_count 6
 addUserKnob {22 collect l Collect T "import os\nimport re\nimport uuid\nimport nuke\n\ndef _find_upstream_read(start):\n    current = start\n    visited = set()\n    while current and current not in visited:\n        visited.add(current)\n        try:\n            if current.Class() == \"Read\":\n                return current\n        except Exception:\n            pass\n        try:\n            current = current.input(0)\n        except Exception:\n            current = None\n    return None\n\ndef _find_upstream_inverse(start):\n    current = start\n    visited = set()\n    while current and current not in visited:\n        visited.add(current)\n        name = \"\"\n        class_name = \"\"\n        try:\n            name = current.name()\n        except Exception:\n            name = \"\"\n        try:\n            class_name = current.Class()\n        except Exception:\n            class_name = \"\"\n        if class_name == \"InverseViewTransform\" or \"InverseViewTransform\" in name:\n            return current\n        try:\n            current = current.input(0)\n        except Exception:\n            current = None\n    return None\n\ndef _collect_versions(folder, ext):\n    if not folder or not os.path.isdir(folder):\n        return []\n    candidates = []\n    for fname in os.listdir(folder):\n        if fname.startswith(\".\"):\n            continue\n        if ext and os.path.splitext(fname)[1].lower() != ext:\n            continue\n        match = re.search(r\"v(\\d+)\", fname, re.IGNORECASE)\n        if not match:\n            continue\n        try:\n            version = int(match.group(1))\n        except ValueError:\n            continue\n        candidates.append((version, fname))\n    candidates.sort(key=lambda item: item[0])\n    return candidates\n\ndef _ensure_input(name, index, x_pos, y_pos):\n    node = nuke.toNode(name)\n    if node is None:\n        node = nuke.createNode(\"Input\")\n    node.setName(name)\n    try:\n        node[\"number\"].setValue(index)\n    except Exception:\n        pass\n    try:\n        node.setXYpos(x_pos, y_pos)\n    except Exception:\n        pass\n    return node\n\ndef _ensure_layers(layer_names):\n    try:\n        existing = set(nuke.layers())\n    except Exception:\n        existing = set()\n    for name in layer_names:\n        if name in existing:\n            continue\n        try:\n            nuke.Layer(name, [\n                \"{0}.red\".format(name),\n                \"{0}.green\".format(name),\n                \"{0}.blue\".format(name),\n            ])\n        except Exception:\n            pass\n\ndef _mapping_for(layer_name, input_index):\n    return (\n        \"3 rgba.red {1} 0 {0}.red 0 0 rgba.green {1} 1 {0}.green 0 1 rgba.blue {1} 2 {0}.blue 0 2\".format(\n            layer_name,\n            input_index,\n        )\n    )\n\ndef _ensure_anchor(node):\n    k = None\n    try:\n        k = node.knob(\"charon_link_anchor\")\n    except Exception:\n        k = None\n    if not k:\n        try:\n            k = nuke.Double_Knob(\"charon_link_anchor\", \"Anchor\")\n            k.setFlag(nuke.NO_ANIMATION | nuke.INVISIBLE)\n            node.addKnob(k)\n        except Exception:\n            k = None\n    return k\n\ndef _ensure_contact_knob(node):\n    k = None\n    try:\n        k = node.knob(\"charon_contact_sheet\")\n    except Exception:\n        k = None\n    if not k:\n        try:\n            k = nuke.String_Knob(\"charon_contact_sheet\", \"Contact Sheet\", \"\")\n            k.setFlag(nuke.NO_ANIMATION | nuke.INVISIBLE)\n            node.addKnob(k)\n        except Exception:\n            k = None\n    return k\n\ndef _copy_node_to_clipboard(node):\n    if node is None:\n        return False\n    try:\n        parent = node.parent() or nuke.root()\n    except Exception:\n        parent = nuke.root()\n    try:\n        current_group = nuke.thisGroup()\n    except Exception:\n        current_group = None\n    try:\n        parent.begin()\n        for n in nuke.selectedNodes():\n            n.setSelected(False)\n        node.setSelected(True)\n        nuke.nodeCopy(\"%clipboard%\")\n        return True\n    except Exception:\n        return False\n    finally:\n        try:\n            node.setSelected(False)\n        except Exception:\n            pass\n        if current_group:\n            current_group.begin()\n\ndef _paste_from_clipboard():\n    before = set(nuke.allNodes())\n    try:\n        nuke.nodePaste(\"%clipboard%\")\n    except Exception:\n        return None\n    pasted = [n for n in nuke.selectedNodes() if n not in before]\n    if pasted:\n        return pasted[0]\n    return None\n\ndef _set_shuffle_inputs(node, from_input1, from_input2):\n    try:\n        node[\"fromInput1\"].setValue(from_input1)\n    except Exception:\n        pass\n    try:\n        node[\"fromInput2\"].setValue(from_input2)\n    except Exception:\n        pass\n\ndef _build_contact_sheet(parent, group, paths, count):\n    if not paths:\n        return\n    try:\n        parent.begin()\n\n        existing_name = \"\"\n        try:\n            existing_name = group.knob(\"charon_contact_sheet\").value()\n        except Exception:\n            existing_name = \"\"\n        if existing_name:\n            try:\n                existing = nuke.toNode(existing_name)\n                if existing:\n                    nuke.delete(existing)\n            except Exception:\n                pass\n\n        for node in list(nuke.allNodes()):\n            try:\n                node_name = node.name()\n            except Exception:\n                node_name = \"\"\n            if node_name.startswith(\"Collect_CS_Read_\"):\n                nuke.delete(node)\n                continue\n            if node_name.startswith(\"Collect_CS_IVT_\"):\n                nuke.delete(node)\n                continue\n            if node_name.startswith(\"Collect_ContactSheet\"):\n                nuke.delete(node)\n\n        for n in nuke.selectedNodes():\n            n.setSelected(False)\n\n        safe_name = \"\".join(c if c.isalnum() else \"_\" for c in group.name())\n        cs_group = nuke.createNode(\"Group\", inpanel=False)\n        cs_group.setName(\"Charon_ContactSheet_{0}\".format(safe_name))\n        try:\n            cs_group[\"tile_color\"].setValue(0xFFFF00FF)\n        except Exception:\n            pass\n        try:\n            cs_group[\"lock_connections\"].setValue(True)\n        except Exception:\n            pass\n        try:\n            cs_group.setXYpos(group.xpos() + 200, group.ypos() + 100)\n        except Exception:\n            pass\n\n        contact_knob = _ensure_contact_knob(group)\n        if contact_knob:\n            try:\n                contact_knob.setValue(cs_group.name())\n            except Exception:\n                pass\n\n        anchor = _ensure_anchor(cs_group)\n        if anchor:\n            try:\n                anchor.setExpression(\"{0}.charon_link_anchor\".format(group.fullName()))\n            except Exception:\n                pass\n\n        cs_group.begin()\n\n        cols = max(1, int(count))\n        rows = (len(paths) + cols - 1) // cols\n\n        cs = nuke.createNode(\"ContactSheet\")\n        cs[\"width\"].setValue(cols * 1024)\n        cs[\"height\"].setValue(rows * 1024)\n        cs[\"rows\"].setValue(rows)\n        cs[\"columns\"].setValue(cols)\n        cs[\"roworder\"].setValue(\"TopBottom\")\n        cs[\"gap\"].setValue(10)\n        cs[\"center\"].setValue(True)\n\n        try:\n            from charon import preferences\n            aces_enabled = preferences.get_preference(\"aces_mode_enabled\", False)\n        except Exception:\n            aces_enabled = False\n\n        ivt_temp = None\n        if aces_enabled:\n            try:\n                from charon.paths import get_charon_temp_dir\n                from charon.processor import INVERSE_VIEW_TRANSFORM_GROUP\n                ivt_temp = os.path.join(get_charon_temp_dir(), \"ivt_cs_{0}.nk\".format(str(uuid.uuid4())[:8])).replace('\\\\', '/')\n                with open(ivt_temp, \"w\") as f:\n                    f.write(INVERSE_VIEW_TRANSFORM_GROUP)\n            except Exception:\n                ivt_temp = None\n\n        try:\n            for i, path in enumerate(paths):\n                r = nuke.createNode(\"Read\")\n                r.setName(\"Collect_CS_Read_{0}\".format(i + 1))\n                r[\"file\"].setValue(path.replace('\\\\', '/'))\n                r[\"on_error\"].setValue(\"nearest frame\")\n                r.setXYpos(i * 150, -300)\n\n                target = r\n                if ivt_temp:\n                    for n in nuke.selectedNodes():\n                        n.setSelected(False)\n                    r.setSelected(True)\n                    try:\n                        nuke.nodePaste(ivt_temp)\n                        ivt_node = nuke.selectedNode()\n                    except Exception:\n                        ivt_node = None\n                    if ivt_node:\n                        ivt_node.setInput(0, r)\n                        ivt_node.setXYpos(r.xpos() + 120, r.ypos())\n                        try:\n                            ivt_node[\"tile_color\"].setValue(0x0000FFFF)\n                            ivt_node[\"gl_color\"].setValue(0x0000FFFF)\n                        except Exception:\n                            pass\n                        ivt_node.setName(\"Collect_CS_IVT_{0}\".format(i + 1))\n                        target = ivt_node\n\n                txt = nuke.createNode(\"Text2\", inpanel=False)\n                txt.setInput(0, target)\n                try:\n                    filename = os.path.basename(path)\n                    txt[\"message\"].setValue(filename)\n                    txt[\"box\"].setValue([0, 0, 1000, 100])\n                    txt[\"yjustify\"].setValue(\"bottom\")\n                    txt[\"global_font_scale\"].setValue(0.5)\n                    try:\n                        txt[\"font\"].setValue(\"Myanmar Text\", \"Regular\")\n                    except Exception:\n                        pass\n                except Exception:\n                    pass\n                txt.setXYpos(r.xpos(), r.ypos() + 150)\n\n                cs.setInput(i, txt)\n                r.setSelected(False)\n                txt.setSelected(False)\n        finally:\n            if ivt_temp:\n                try:\n                    if os.path.exists(ivt_temp):\n                        os.remove(ivt_temp)\n                except Exception:\n                    pass\n\n        out = nuke.createNode(\"Output\")\n        out.setInput(0, cs)\n        out.setXYpos(cs.xpos(), cs.ypos() + 200)\n\n        cs_group.end()\n    finally:\n        if group:\n            group.begin()\n\ndef _run():\n    group = nuke.thisNode()\n    parent = group.parent() or nuke.root()\n    try:\n        count = int(group[\"camera_count\"].value())\n    except Exception:\n        count = 0\n    if count <= 0:\n        nuke.message(\"Number of Cameras must be greater than 0.\")\n        return\n\n    layer_names = [\n        \"projection_CamInit\",\n        \"projection_Cam60\",\n        \"projection_Cam120\",\n        \"projection_Cam180\",\n        \"projection_Cam300\",\n        \"projection_Cam240\",\n    ]\n    if count > len(layer_names):\n        count = len(layer_names)\n\n    inputs_ext = None\n    try:\n        inputs_ext = group.input(0)\n    except Exception:\n        pass\n\n    inputs_read = _find_upstream_read(inputs_ext)\n    ivt_source = _find_upstream_inverse(inputs_ext)\n\n    inputs_file = \"\"\n    if inputs_read and inputs_read.knob(\"file\"):\n        try:\n            inputs_file = inputs_read[\"file\"].value()\n        except Exception:\n            inputs_file = \"\"\n\n    folder = os.path.dirname(inputs_file) if inputs_file else \"\"\n    ext = os.path.splitext(inputs_file)[1].lower() if inputs_file else \"\"\n    candidates = _collect_versions(folder, ext)\n    needed = count\n    if needed and not candidates:\n        nuke.message(\"No v## images found in: {}\".format(folder))\n    tail = candidates[-needed:] if needed else []\n    mirrored_paths = [\n        os.path.join(folder, fname).replace('\\\\', '/')\n        for _, fname in tail\n    ]\n\n    _ensure_layers(layer_names[:count])\n\n    _ensure_anchor(group)\n\n    has_ivt = False\n    if ivt_source:\n        has_ivt = _copy_node_to_clipboard(ivt_source)\n\n    group.begin()\n    try:\n        for node in list(nuke.allNodes()):\n            node_name = \"\"\n            try:\n                node_name = node.name()\n            except Exception:\n                node_name = \"\"\n            if node_name.startswith(\"Collect_Read_\"):\n                nuke.delete(node)\n                continue\n            if node_name.startswith(\"Collect_IVT_\"):\n                nuke.delete(node)\n                continue\n            if node_name.startswith(\"Collect_Shuffle_\"):\n                nuke.delete(node)\n                continue\n\n        _ensure_input(\"inputs\", 0, -200, -40)\n\n        prev_output = None\n        for index in range(count):\n            read_node = nuke.createNode(\"Read\")\n            read_node.setName(\"Collect_Read_{0}\".format(index + 1))\n            try:\n                read_node[\"on_error\"].setValue(\"nearest frame\")\n            except Exception:\n                pass\n            if index < len(mirrored_paths):\n                read_node[\"file\"].setValue(mirrored_paths[index])\n            try:\n                read_node.setXYpos(-60, 40 + index * 80)\n            except Exception:\n                pass\n            target_node = read_node\n            if has_ivt:\n                ivt_node = _paste_from_clipboard()\n                if ivt_node:\n                    try:\n                        ivt_node.setName(\"Collect_IVT_{0}\".format(index + 1))\n                    except Exception:\n                        pass\n                    try:\n                        ivt_node.setInput(0, read_node)\n                    except Exception:\n                        pass\n                    try:\n                        ivt_node.setXYpos(read_node.xpos() + 120, read_node.ypos())\n                    except Exception:\n                        pass\n                    target_node = ivt_node\n\n            shuffle_node = nuke.createNode(\"Shuffle2\")\n            shuffle_node.setName(\"Collect_Shuffle_{0}\".format(index + 1))\n            if index == 0:\n                try:\n                    shuffle_node.setInput(1, target_node)\n                except Exception:\n                    pass\n                _set_shuffle_inputs(shuffle_node, 0, 0)\n            else:\n                try:\n                    shuffle_node.setInput(0, prev_output)\n                except Exception:\n                    pass\n                try:\n                    shuffle_node.setInput(1, target_node)\n                except Exception:\n                    pass\n                _set_shuffle_inputs(shuffle_node, 1, 0)\n            try:\n                shuffle_node[\"out1\"].setValue(layer_names[index])\n            except Exception:\n                pass\n            try:\n                shuffle_node[\"mappings\"].setValue(_mapping_for(layer_names[index], 0))\n            except Exception:\n                pass\n            try:\n                shuffle_node.setXYpos(target_node.xpos() + 200, target_node.ypos())\n            except Exception:\n                pass\n\n            prev_output = shuffle_node\n\n        output = nuke.toNode(\"Output1\")\n        if output is None:\n            output = nuke.createNode(\"Output\")\n        try:\n            output.setInput(0, prev_output)\n        except Exception:\n            pass\n        try:\n            output.setXYpos(460, 40 + count * 80)\n        except Exception:\n            pass\n    finally:\n        group.end()\n\n    _build_contact_sheet(parent, group, mirrored_paths, count)\n\n_run()\n"}
}
 Input {
  name inputs
  number 0
  xpos -200
  ypos -40
 }
 Output {
  name Output1
  xpos 460
  ypos 520
 }
end_group
