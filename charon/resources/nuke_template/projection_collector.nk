Group {
 inputs 2
 name Projection_Collector
 addUserKnob {20 User}
 addUserKnob {7 camera_count l "Number of Cameras"}
 camera_count 8
 addUserKnob {7 which_input l "Which Input"}
 which_input 0
 addUserKnob {22 collect l Collect T "import os\nimport re\nimport nuke\n\ndef _find_upstream_read(start):\n    current = start\n    visited = set()\n    while current and current not in visited:\n        visited.add(current)\n        try:\n            if current.Class() == \"Read\":\n                return current\n        except Exception:\n            pass\n        try:\n            current = current.input(0)\n        except Exception:\n            current = None\n    return None\n\ndef _find_upstream_inverse(start):\n    current = start\n    visited = set()\n    while current and current not in visited:\n        visited.add(current)\n        name = \"\"\n        class_name = \"\"\n        try:\n            name = current.name()\n        except Exception:\n            name = \"\"\n        try:\n            class_name = current.Class()\n        except Exception:\n            class_name = \"\"\n        if class_name == \"InverseViewTransform\" or \"InverseViewTransform\" in name:\n            return current\n        try:\n            current = current.input(0)\n        except Exception:\n            current = None\n    return None\n\ndef _collect_versions(folder, ext):\n    if not folder or not os.path.isdir(folder):\n        return []\n    candidates = []\n    for fname in os.listdir(folder):\n        if fname.startswith(\".\"):\n            continue\n        if ext and os.path.splitext(fname)[1].lower() != ext:\n            continue\n        match = re.search(r\"v(\\d+)\", fname, re.IGNORECASE)\n        if not match:\n            continue\n        try:\n            version = int(match.group(1))\n        except ValueError:\n            continue\n        candidates.append((version, fname))\n    candidates.sort(key=lambda item: item[0])\n    return candidates\n\ndef _ensure_input(name, index, x_pos, y_pos):\n    node = nuke.toNode(name)\n    if node is None:\n        node = nuke.createNode(\"Input\")\n    node.setName(name)\n    try:\n        node[\"number\"].setValue(index)\n    except Exception:\n        pass\n    try:\n        node.setXYpos(x_pos, y_pos)\n    except Exception:\n        pass\n    return node\n\ndef _copy_node_to_clipboard(node):\n    if node is None:\n        return False\n    try:\n        parent = node.parent() or nuke.root()\n    except Exception:\n        parent = nuke.root()\n    try:\n        current_group = nuke.thisGroup()\n    except Exception:\n        current_group = None\n    try:\n        parent.begin()\n        for n in nuke.selectedNodes():\n            n.setSelected(False)\n        node.setSelected(True)\n        nuke.nodeCopy(\"%clipboard%\")\n        return True\n    except Exception:\n        return False\n    finally:\n        try:\n            node.setSelected(False)\n        except Exception:\n            pass\n        if current_group:\n            current_group.begin()\n\ndef _paste_from_clipboard():\n    before = set(nuke.allNodes())\n    try:\n        nuke.nodePaste(\"%clipboard%\")\n    except Exception:\n        return None\n    pasted = [n for n in nuke.selectedNodes() if n not in before]\n    if pasted:\n        return pasted[0]\n    return None\n\ndef _run():\n    group = nuke.thisNode()\n    try:\n        count = int(group[\"camera_count\"].value())\n    except Exception:\n        count = 0\n    if count <= 0:\n        nuke.message(\"Number of Cameras must be greater than 0.\")\n        return\n\n    inputs_ext = None\n    master_ext = None\n    try:\n        inputs_ext = group.input(0)\n        master_ext = group.input(1)\n    except Exception:\n        pass\n\n    inputs_read = _find_upstream_read(inputs_ext)\n    ivt_source = _find_upstream_inverse(inputs_ext)\n\n    inputs_file = \"\"\n    if inputs_read and inputs_read.knob(\"file\"):\n        try:\n            inputs_file = inputs_read[\"file\"].value()\n        except Exception:\n            inputs_file = \"\"\n\n    folder = os.path.dirname(inputs_file) if inputs_file else \"\"\n    ext = os.path.splitext(inputs_file)[1].lower() if inputs_file else \"\"\n    candidates = _collect_versions(folder, ext)\n    needed = max(count - 1, 0)\n    if needed and not candidates:\n        nuke.message(\"No v## images found in: {}\".format(folder))\n    tail = candidates[-needed:] if needed else []\n    mirrored_paths = [\n        os.path.join(folder, fname).replace(\"\\\\\", \"/\")\n        for _, fname in tail\n    ]\n\n    has_ivt = False\n    if ivt_source:\n        has_ivt = _copy_node_to_clipboard(ivt_source)\n\n    group.begin()\n    try:\n        for node in list(nuke.allNodes()):\n            node_name = \"\"\n            node_class = \"\"\n            try:\n                node_name = node.name()\n            except Exception:\n                node_name = \"\"\n            try:\n                node_class = node.Class()\n            except Exception:\n                node_class = \"\"\n            if node_class == \"Read\" and node_name.startswith(\"Collect_Read_\"):\n                nuke.delete(node)\n                continue\n            if node_name.startswith(\"Collect_IVT_\"):\n                nuke.delete(node)\n\n        input_inputs = _ensure_input(\"inputs\", 0, -100, -40)\n        input_master = _ensure_input(\"master\", 1, -100, 60)\n\n        switch = nuke.toNode(\"CamSwitch\")\n        if switch is None:\n            switch = nuke.createNode(\"Switch\")\n        switch.setName(\"CamSwitch\")\n        try:\n            switch.setXYpos(200, 40)\n        except Exception:\n            pass\n        try:\n            switch.setInput(0, input_master)\n        except Exception:\n            pass\n        try:\n            switch[\"which\"].setExpression(\"parent.which_input\")\n        except Exception:\n            try:\n                switch[\"which\"].setValue(int(group[\"which_input\"].value()))\n            except Exception:\n                pass\n\n        output = nuke.toNode(\"Output1\")\n        if output is None:\n            output = nuke.createNode(\"Output\")\n        try:\n            output.setInput(0, switch)\n        except Exception:\n            pass\n        try:\n            output.setXYpos(200, switch.ypos() + 120)\n        except Exception:\n            pass\n\n        for index in range(1, count):\n            read_node = nuke.createNode(\"Read\")\n            read_node.setName(\"Collect_Read_{0}\".format(index + 1))\n            try:\n                read_node[\"on_error\"].setValue(\"nearest frame\")\n            except Exception:\n                pass\n            path_index = index - 1\n            if path_index < len(mirrored_paths):\n                read_node[\"file\"].setValue(mirrored_paths[path_index])\n            try:\n                read_node.setXYpos(0, index * 80)\n            except Exception:\n                pass\n            target_node = read_node\n            if has_ivt:\n                ivt_node = _paste_from_clipboard()\n                if ivt_node:\n                    try:\n                        ivt_node.setName(\"Collect_IVT_{0}\".format(index + 1))\n                    except Exception:\n                        pass\n                    try:\n                        ivt_node.setInput(0, read_node)\n                    except Exception:\n                        pass\n                    try:\n                        ivt_node.setXYpos(read_node.xpos() + 120, read_node.ypos())\n                    except Exception:\n                        pass\n                    target_node = ivt_node\n            try:\n                switch.setInput(index, target_node)\n            except Exception:\n                pass\n        try:\n            input_inputs.setSelected(False)\n            input_master.setSelected(False)\n        except Exception:\n            pass\n    finally:\n        group.end()\n\n_run()"}
}
 Input {
  name inputs
  number 0
  xpos -100
  ypos -40
 }
 Input {
  name master
  number 1
  xpos -100
  ypos 60
 }
 Switch {
  inputs 0
  name CamSwitch
  xpos 200
  ypos 40
 }
 Output {
  name Output1
  xpos 200
  ypos 160
 }
end_group
